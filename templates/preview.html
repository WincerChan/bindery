{% extends "base.html" %}

{% block title %}{{ book.title }} · 阅读器{% endblock %}

{% block content %}
{% set detail_url = "/book/" ~ book.book_id ~ return_to_query %}
<div
  x-data="binderyReader()"
  class="h-full w-full flex flex-col relative"
  :class="readerBg === 'paper' ? 'bg-amber-50' : readerBg === 'sand' ? 'bg-stone-100' : readerBg === 'mint' ? 'bg-emerald-50' : 'bg-slate-50'"
>
  <div class="fixed top-0 left-0 right-0 z-40 h-9">
    <header
      class="relative h-9 border-b border-slate-200/60 flex items-center gap-2 px-2"
    >
      <button
        type="button"
        class="inline-flex items-center justify-center w-8 h-8 rounded-lg hover:bg-slate-100 text-slate-700 transition-colors cursor-pointer"
        aria-label="切换目录"
        @click="tocOpen = !tocOpen"
      >
        <svg viewBox="0 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path d="M4 6h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M4 12h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>
      </button>

      <a
        href="{{ detail_url }}"
        class="sm:hidden inline-flex items-center justify-center w-8 h-8 rounded-lg hover:bg-slate-100 text-slate-700 transition-colors"
        aria-label="返回详情"
        title="返回详情"
      >
        <svg viewBox="0 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path d="M15 18 9 12l6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </a>

      <a
        href="{{ detail_url }}"
        class="hidden sm:inline-flex items-center h-8 px-2 rounded-lg text-xs font-medium text-slate-700 hover:bg-slate-100 transition-colors"
      >返回详情</a>

      <div class="absolute inset-0 flex items-center justify-center px-20 sm:px-24 pointer-events-none">
        <div class="max-w-full truncate text-[13px] font-semibold text-slate-900" x-text="bookTitle + ' · ' + currentSectionTitle()"></div>
      </div>

      <button
        type="button"
        class="inline-flex items-center justify-center w-8 h-8 rounded-lg hover:bg-slate-100 text-slate-700 transition-colors ml-auto cursor-pointer"
        aria-label="设置"
        title="设置"
        @click="settingsOpen = !settingsOpen"
      >
        <svg viewBox="0 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path
            d="M12 15.25a3.25 3.25 0 1 0 0-6.5 3.25 3.25 0 0 0 0 6.5Z"
            stroke="currentColor"
            stroke-width="2"
          ></path>
          <path
            d="M19.2 12a7.5 7.5 0 0 0-.08-1l2.02-1.57-2-3.46-2.43.98a7.35 7.35 0 0 0-1.74-1l-.37-2.58H9.4l-.37 2.58a7.35 7.35 0 0 0-1.74 1l-2.43-.98-2 3.46L4.88 11a7.5 7.5 0 0 0 0 2l-2.02 1.57 2 3.46 2.43-.98a7.35 7.35 0 0 0 1.74 1l.37 2.58h5.2l.37-2.58a7.35 7.35 0 0 0 1.74-1l2.43.98 2-3.46L19.12 13c.05-.33.08-.66.08-1Z"
            stroke="currentColor"
            stroke-width="2"
            stroke-linejoin="round"
          ></path>
        </svg>
      </button>
    </header>
  </div>

  <div
    class="absolute top-10 right-2 z-50 w-80 max-w-[calc(100vw-1rem)] rounded-xl bg-white border border-slate-200 shadow-lg p-3"
    x-show="settingsOpen"
    x-cloak
    x-transition.opacity
    @click.outside="settingsOpen = false"
  >
    <div class="flex items-center justify-between gap-2">
      <div class="text-xs font-semibold text-slate-500 uppercase tracking-wide">设置</div>
      <button
        type="button"
        class="w-9 h-9 inline-flex items-center justify-center rounded-lg hover:bg-slate-100 text-slate-700 transition-colors cursor-pointer"
        aria-label="关闭设置"
        @click="settingsOpen = false"
      >
        <svg viewBox="0 0 24 24" fill="none" class="w-5 h-5" aria-hidden="true">
          <path d="M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>
      </button>
    </div>

    <div class="mt-3 space-y-3">
      <div>
        <div class="text-xs font-semibold text-slate-500 uppercase tracking-wide">背景</div>
        <div class="mt-2 grid grid-cols-3 gap-2">
          <button
            type="button"
            class="h-9 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'book' ? 'border-indigo-500 ring-2 ring-indigo-200' : 'border-slate-200 hover:border-slate-300'"
            @click="readerBg = 'book'"
          >书籍</button>
          <button
            type="button"
            class="h-9 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'slate' ? 'border-indigo-500 ring-2 ring-indigo-200' : 'border-slate-200 hover:border-slate-300'"
            @click="readerBg = 'slate'"
          >灰白</button>
          <button
            type="button"
            class="h-9 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'paper' ? 'border-indigo-500 ring-2 ring-indigo-200' : 'border-slate-200 hover:border-slate-300'"
            @click="readerBg = 'paper'"
          >纸张</button>
          <button
            type="button"
            class="h-9 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'sand' ? 'border-indigo-500 ring-2 ring-indigo-200' : 'border-slate-200 hover:border-slate-300'"
            @click="readerBg = 'sand'"
          >砂岩</button>
          <button
            type="button"
            class="h-9 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'mint' ? 'border-indigo-500 ring-2 ring-indigo-200' : 'border-slate-200 hover:border-slate-300'"
            @click="readerBg = 'mint'"
          >薄荷</button>
        </div>
      </div>

      <div>
        <div class="text-xs font-semibold text-slate-500 uppercase tracking-wide">样式</div>
        <div class="mt-2 flex items-center gap-1 p-1 rounded-xl bg-slate-100 border border-slate-200">
          <button
            type="button"
            class="flex-1 px-2.5 py-1.5 rounded-lg text-sm font-medium transition-colors cursor-pointer"
            :class="styleMode === 'book' ? 'bg-white text-slate-900 shadow-sm' : 'text-slate-600 hover:text-slate-900'"
            @click="styleMode = 'book'"
          >书籍</button>
          <button
            type="button"
            class="flex-1 px-2.5 py-1.5 rounded-lg text-sm font-medium transition-colors cursor-pointer"
            :class="styleMode === 'custom' ? 'bg-white text-slate-900 shadow-sm' : 'text-slate-600 hover:text-slate-900'"
            @click="styleMode = 'custom'"
          >自定义</button>
        </div>
        <div class="mt-2 text-xs text-slate-500">书籍：尽量保持 EPUB 原样式；自定义：覆盖字体/字号/行高。</div>
      </div>

      <div x-show="styleMode === 'custom'" x-transition.opacity class="space-y-3">
        <div class="grid grid-cols-2 gap-2">
          <label class="text-xs font-semibold text-slate-500 uppercase tracking-wide self-center">字体</label>
          <select
            class="px-2 py-1.5 border border-slate-200 rounded-lg bg-white text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
            x-model="fontFamily"
          >
            <option value="serif">衬线</option>
            <option value="sans">无衬线</option>
            <option value="mono">等宽</option>
          </select>

          <label class="text-xs font-semibold text-slate-500 uppercase tracking-wide self-center">字号</label>
          <div class="flex items-center gap-2">
            <button
              type="button"
              class="w-9 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
              aria-label="减小字号"
              @click="decFont()"
            >A-</button>
            <div class="flex-1 text-center text-xs font-mono text-slate-500" x-text="fontSize + 'px'"></div>
            <button
              type="button"
              class="w-9 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
              aria-label="增大字号"
              @click="incFont()"
            >A+</button>
          </div>

          <label class="text-xs font-semibold text-slate-500 uppercase tracking-wide self-center">行高</label>
          <select
            class="px-2 py-1.5 border border-slate-200 rounded-lg bg-white text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
            x-model="lineHeight"
          >
            <option value="1.55">1.55</option>
            <option value="1.65">1.65</option>
            <option value="1.75">1.75</option>
            <option value="1.85">1.85</option>
            <option value="1.95">1.95</option>
            <option value="2.05">2.05</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="flex-1 min-h-0 flex relative pt-9">
    <div
      class="absolute inset-0 bg-black/30 z-50"
      x-show="tocOpen"
      x-cloak
      x-transition.opacity
      @click="tocOpen = false"
    ></div>

    <aside
      class="absolute inset-y-0 left-0 z-50 w-72 bg-white border-r border-slate-200 overflow-y-auto transform transition-transform duration-200 ease-out"
      x-cloak
      :class="tocOpen ? 'translate-x-0' : '-translate-x-full'"
    >
      <div class="sticky top-0 bg-white border-b border-slate-200 p-3">
        <div class="flex items-start gap-3">
          <div class="w-12 aspect-[2/3] rounded-lg overflow-hidden border border-slate-200 bg-slate-100 shadow-sm shrink-0">
            {% if book.cover_url %}
              <img src="{{ book.cover_url }}" alt="{{ book.title }}" class="w-full h-full object-cover" loading="lazy" />
            {% else %}
              <div class="w-full h-full flex items-center justify-center text-slate-500 font-bold text-sm">B</div>
            {% endif %}
          </div>

          <div class="min-w-0 flex-1">
            <div class="text-sm font-semibold text-slate-900 truncate">{{ book.title }}</div>
            <div class="text-xs text-slate-500 truncate mt-0.5">{{ book.author or "未知" }}</div>
            <div class="text-xs text-slate-500 mt-2" x-text="'共 ' + tocCount + ' 节 · 当前 ' + (sectionIndex + 1)"></div>
          </div>

          <button
            type="button"
            class="w-9 h-9 inline-flex items-center justify-center rounded-lg hover:bg-slate-100 text-slate-700 transition-colors cursor-pointer"
            aria-label="关闭目录"
            @click="tocOpen = false"
          >
            <svg viewBox="0 0 24 24" fill="none" class="w-5 h-5" aria-hidden="true">
              <path d="M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
              <path d="M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
            </svg>
          </button>
        </div>
      </div>

      <nav class="p-2 space-y-1">
        {% for item in toc %}
          <a
            href="/book/{{ book.book_id }}/preview/{{ item.index }}{{ return_to_query }}"
            class="flex items-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors text-slate-700 hover:bg-slate-50"
            :class="sectionIndex === {{ item.index }} ? 'bg-indigo-50 text-indigo-700' : ''"
            @click.prevent="gotoSection({{ item.index }}, { desiredPage: 1 })"
            :data-current-toc="sectionIndex === {{ item.index }} ? '1' : null"
            title="{{ item.title }}"
          >
            <span class="truncate">{{ item.title }}</span>
          </a>
        {% endfor %}
      </nav>
    </aside>

    <div class="flex-1 min-h-0 flex items-stretch justify-center">
      <div class="w-full max-w-[600px] min-h-0 flex flex-col pb-9">
        <div class="w-full flex-1 min-h-0 bg-white border-x border-slate-200 shadow-sm relative overflow-hidden">
          <iframe
            x-ref="frameA"
            class="absolute inset-0 w-full h-full bg-white transition-opacity duration-100"
            :class="activeFrameKey === 'a' ? 'opacity-100 z-10' : 'opacity-0 z-0 pointer-events-none'"
            sandbox="allow-same-origin"
            referrerpolicy="no-referrer"
            loading="lazy"
            :title="currentSectionTitle()"
          ></iframe>
          <iframe
            x-ref="frameB"
            class="absolute inset-0 w-full h-full bg-white transition-opacity duration-100"
            :class="activeFrameKey === 'b' ? 'opacity-100 z-10' : 'opacity-0 z-0 pointer-events-none'"
            sandbox="allow-same-origin"
            referrerpolicy="no-referrer"
            loading="lazy"
            :title="currentSectionTitle()"
          ></iframe>
          <div
            class="absolute inset-0 z-20 flex items-center justify-center bg-white/75 text-xs font-medium text-slate-600"
            x-show="chapterSwitching"
            x-cloak
          >章节切换中...</div>
        </div>
      </div>
    </div>
  </div>

  <button
    type="button"
    class="fixed left-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-white/90 border border-slate-200 shadow-sm text-slate-800 hover:bg-white transition-opacity flex items-center justify-center disabled:opacity-40 disabled:cursor-not-allowed cursor-pointer"
    aria-label="上一页"
    title="上一页（← / PageUp）"
    @click="pagePrev()"
    :disabled="!canPagePrev()"
    :class="(tocOpen || settingsOpen) ? 'opacity-0 pointer-events-none' : 'opacity-100'"
  >
    <svg viewBox="0 0 24 24" fill="none" class="w-6 h-6" aria-hidden="true">
      <path d="M15 18 9 12l6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  </button>

  <button
    type="button"
    class="fixed right-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-white/90 border border-slate-200 shadow-sm text-slate-800 hover:bg-white transition-opacity flex items-center justify-center disabled:opacity-40 disabled:cursor-not-allowed cursor-pointer"
    aria-label="下一页"
    title="下一页（→ / PageDown / 空格）"
    @click="pageNext()"
    :disabled="!canPageNext()"
    :class="(tocOpen || settingsOpen) ? 'opacity-0 pointer-events-none' : 'opacity-100'"
  >
    <svg viewBox="0 0 24 24" fill="none" class="w-6 h-6" aria-hidden="true">
      <path d="m9 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  </button>

  <div
    class="fixed bottom-0 left-0 right-0 z-40 h-9 flex justify-center transition-opacity"
    :class="(tocOpen || settingsOpen) ? 'opacity-0 pointer-events-none' : 'opacity-100'"
  >
    <div
      class="w-full max-w-[600px] h-9 flex items-center px-3 border-t border-x border-dashed border-slate-200/60 text-xs text-slate-600"
      :class="readerBg === 'book' ? 'bg-white' : readerBg === 'paper' ? 'bg-amber-50' : readerBg === 'sand' ? 'bg-stone-100' : readerBg === 'mint' ? 'bg-emerald-50' : 'bg-slate-50'"
    >
      <div class="flex-1 font-mono truncate" x-text="page + ' / ' + pageCount + ' · ' + Math.round((page / pageCount) * 100) + '%'"></div>
      <div class="font-mono tabular-nums" x-text="timeNow"></div>
    </div>
  </div>
</div>

<script>
  function binderyReader() {
    const storageKey = "bindery:reader";
    const progressStoragePrefix = "bindery:reader:progress:";
    const bookId = {{ book.book_id|tojson }};
    const bookTitle = {{ book.title|tojson }};
    const sectionsData = {{ sections_payload|tojson }};
    const initialSectionIndex = {{ section_index }};
    const tocCount = sectionsData.length;
    const returnTo = {{ return_to|tojson }};
    const sectionBaseUrl = "/book/{{ book.book_id }}/preview/";
    const fonts = {
      serif: 'ui-serif, Georgia, Cambria, "Times New Roman", Times, serif',
      sans: 'ui-sans-serif, system-ui, -apple-system, "Segoe UI", sans-serif',
      mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
    };
    const bgColors = {
      slate: "#f8fafc",
      paper: "#fffbeb",
      sand: "#f5f5f4",
      mint: "#ecfdf5",
    };
    const maxPageWidth = 600;
    const urlParams = new URLSearchParams(window.location.search);
    const resumeRequested = urlParams.get("resume") === "1";
    const navReason = (urlParams.get("nav") || "").toLowerCase();
    const explicitPageParam = (urlParams.get("page") || "").toLowerCase();

    function clampInt(value, min, max, fallback) {
      const n = Number.parseInt(String(value || ""), 10);
      if (Number.isNaN(n)) return fallback;
      return Math.max(min, Math.min(max, n));
    }

    function clampFloat(value, min, max, fallback) {
      const n = Number.parseFloat(String(value || ""));
      if (Number.isNaN(n)) return fallback;
      return Math.max(min, Math.min(max, n));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function saveSettings(data) {
      try {
        localStorage.setItem(storageKey, JSON.stringify(data));
      } catch {
        // ignore
      }
    }

    function progressKey(id) {
      return progressStoragePrefix + id;
    }

    function loadProgress(id) {
      try {
        const raw = localStorage.getItem(progressKey(id));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveProgress(id, data) {
      try {
        localStorage.setItem(progressKey(id), JSON.stringify(data));
      } catch {
        // ignore
      }
    }

    function sectionUrl(index, extraParams) {
      const params = new URLSearchParams();
      if (returnTo && returnTo !== "/") params.set("return_to", returnTo);
      if (extraParams && typeof extraParams === "object") {
        for (const [k, v] of Object.entries(extraParams)) {
          if (v === undefined || v === null || v === "") continue;
          params.set(k, String(v));
        }
      }
      const query = params.toString();
      return query ? `${sectionBaseUrl}${index}?${query}` : `${sectionBaseUrl}${index}`;
    }

    return {
      tocOpen: false,
      settingsOpen: false,
      chapterSwitching: false,
      readerBg: "book",
      styleMode: "book",
      fontFamily: "serif",
      fontSize: 18,
      lineHeight: 1.85,
      timeNow: "",
      page: 1,
      pageCount: 1,
      bookId,
      bookTitle,
      sections: sectionsData,
      sectionIndex: initialSectionIndex,
      tocCount,
      activeFrameKey: "a",
      _jumpToLast: false,
      _resumePage: null,
      _lastChapterDirection: 1,
      _clockTimer: null,
      _scrollEndTimer: null,
      _resizeTimer: null,
      _progressTimer: null,
      _idlePreloadToken: null,
      _pendingSwitch: null,
      _prefetchCache: {},
      _prefetchInflight: {},
      _frameState: {
        a: { section: null, ready: false, desiredPage: 1 },
        b: { section: null, ready: false, desiredPage: 1 },
      },
      _frameApplied: { a: false, b: false },
      _frameApplying: { a: false, b: false },
      currentSectionTitle() {
        const section = this.sections[this.sectionIndex];
        return section ? section.title : "";
      },
      _updateTimeNow() {
        try {
          this.timeNow = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        } catch {
          const now = new Date();
          const hh = String(now.getHours()).padStart(2, "0");
          const mm = String(now.getMinutes()).padStart(2, "0");
          this.timeNow = hh + ":" + mm;
        }
      },
      _persist() {
        saveSettings({
          readerBg: this.readerBg,
          styleMode: this.styleMode,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          lineHeight: this.lineHeight,
        });
      },
      _persistProgressNow() {
        saveProgress(this.bookId, {
          section: this.sectionIndex,
          page: Math.max(1, Number(this.page) || 1),
          pageCount: Math.max(1, Number(this.pageCount) || 1),
          updatedAt: Date.now(),
        });
      },
      _persistProgressSoon() {
        if (this._progressTimer) clearTimeout(this._progressTimer);
        this._progressTimer = setTimeout(() => this._persistProgressNow(), 120);
      },
      _otherFrameKey(key) {
        return key === "a" ? "b" : "a";
      },
      getFrame(key) {
        return key === "a" ? this.$refs.frameA : this.$refs.frameB;
      },
      getActiveFrame() {
        return this.getFrame(this.activeFrameKey);
      },
      _applyLayoutWithAnchor() {
        this.applyToFrame({ frameKey: this.activeFrameKey, preserveAnchor: true });
        const bufferKey = this._otherFrameKey(this.activeFrameKey);
        if (this._frameState[bufferKey].ready) {
          this.applyToFrame({ frameKey: bufferKey, primeOnly: true });
        }
      },
      _scrollCurrentTocIntoView() {
        this.$nextTick(() => {
          const current = this.$root.querySelector("[data-current-toc='1']");
          if (!current || typeof current.scrollIntoView !== "function") return;
          current.scrollIntoView({ block: "center", inline: "nearest" });
        });
      },
      _sectionIndexFromLocation() {
        const match = window.location.pathname.match(/\/preview\/(\d+)\/?$/);
        if (!match) return null;
        const parsed = Number.parseInt(match[1], 10);
        if (!Number.isInteger(parsed)) return null;
        if (parsed < 0 || parsed >= this.tocCount) return null;
        return parsed;
      },
      _scheduleIdle(task, timeout = 600) {
        if ("requestIdleCallback" in window) {
          return window.requestIdleCallback(task, { timeout });
        }
        return window.setTimeout(() => task({ didTimeout: false, timeRemaining: () => 0 }), 120);
      },
      _cancelIdle(token) {
        if (token == null) return;
        if ("cancelIdleCallback" in window) {
          window.cancelIdleCallback(token);
          return;
        }
        window.clearTimeout(token);
      },
      _prefetchSectionHtml(index) {
        if (!Number.isInteger(index) || index < 0 || index >= this.tocCount) return;
        if (this._prefetchCache[index] || this._prefetchInflight[index]) return;
        const section = this.sections[index];
        if (!section || !section.content_url) return;
        this._prefetchInflight[index] = true;
        fetch(section.content_url, { credentials: "same-origin" })
          .then((response) => (response.ok ? response.text() : ""))
          .then((html) => {
            if (html) this._prefetchCache[index] = html;
          })
          .catch(() => {
            // ignore
          })
          .finally(() => {
            delete this._prefetchInflight[index];
          });
      },
      _loadSectionIntoFrame(frameKey, targetIndex, desiredPage) {
        const frame = this.getFrame(frameKey);
        const section = this.sections[targetIndex];
        if (!frame || !section) return;
        const state = this._frameState[frameKey];
        if (state.section === targetIndex && state.ready) return;
        state.section = targetIndex;
        state.desiredPage = Math.max(1, Number.parseInt(String(desiredPage || 1), 10) || 1);
        state.ready = false;

        const cached = this._prefetchCache[targetIndex];
        if (cached) {
          frame.removeAttribute("src");
          frame.srcdoc = cached;
          return;
        }
        frame.removeAttribute("srcdoc");
        frame.src = section.content_url;
      },
      _updateHistoryForSection(targetIndex, mode) {
        const target = sectionUrl(targetIndex);
        if (mode === "replace") {
          history.replaceState({ section: targetIndex }, "", target);
          return;
        }
        history.pushState({ section: targetIndex }, "", target);
      },
      _scheduleChapterPreload() {
        if (this._idlePreloadToken) this._cancelIdle(this._idlePreloadToken);
        this._idlePreloadToken = this._scheduleIdle(() => {
          const preferred = this.sectionIndex + (this._lastChapterDirection >= 0 ? 1 : -1);
          const fallback = this.sectionIndex + (this._lastChapterDirection >= 0 ? -1 : 1);
          let target = preferred;
          if (target < 0 || target >= this.tocCount) {
            target = fallback;
          }
          if (target < 0 || target >= this.tocCount) return;
          const bufferKey = this._otherFrameKey(this.activeFrameKey);
          this._prefetchSectionHtml(target);
          this._loadSectionIntoFrame(bufferKey, target, 1);
        });
      },
      _bindFrameLoad(frameKey) {
        const frame = this.getFrame(frameKey);
        if (!frame || frame.dataset.binderyFrameListener) return;
        frame.dataset.binderyFrameListener = "1";
        frame.addEventListener("load", () => this._onFrameLoaded(frameKey));
      },
      _onFrameLoaded(frameKey) {
        const state = this._frameState[frameKey];
        if (!state || state.section === null) return;
        const primeOnly = frameKey !== this.activeFrameKey;
        this.applyToFrame({
          frameKey,
          preserveAnchor: false,
          primeOnly,
          desiredPage: state.desiredPage,
          onDone: () => {
            state.ready = true;
            const pending = this._pendingSwitch;
            if (pending && pending.frameKey === frameKey && pending.sectionIndex === state.section) {
              this._activateFrame(frameKey, pending.sectionIndex, pending.desiredPage, pending.historyMode);
            }
          },
        });
      },
      _activateFrame(frameKey, targetIndex, desiredPage, historyMode) {
        this.activeFrameKey = frameKey;
        this.sectionIndex = targetIndex;
        this.page = 1;
        this.pageCount = 1;
        this.chapterSwitching = false;
        this._pendingSwitch = null;
        this.refreshPagination({ desiredPage: desiredPage || 1, behavior: "auto" });
        this._persistProgressSoon();
        this._scrollCurrentTocIntoView();
        this._updateHistoryForSection(targetIndex, historyMode || "push");
        this._scheduleChapterPreload();
      },
      gotoSection(targetIndex, opts) {
        const parsedTarget = Number.parseInt(String(targetIndex), 10);
        if (!Number.isInteger(parsedTarget)) return;
        if (parsedTarget < 0 || parsedTarget >= this.tocCount) return;
        if (parsedTarget === this.sectionIndex) {
          if (opts && Number.isInteger(opts.desiredPage)) {
            this.scrollToPage(Math.max(1, opts.desiredPage), "auto");
          }
          this.tocOpen = false;
          return;
        }

        const desiredPage = opts && Number.isInteger(opts.desiredPage) ? Math.max(1, opts.desiredPage) : 1;
        const historyMode = (opts && opts.historyMode) || "push";
        this._lastChapterDirection = parsedTarget > this.sectionIndex ? 1 : -1;
        this.tocOpen = false;

        const bufferKey = this._otherFrameKey(this.activeFrameKey);
        const bufferState = this._frameState[bufferKey];
        if (bufferState.section === parsedTarget && bufferState.ready) {
          this._activateFrame(bufferKey, parsedTarget, desiredPage, historyMode);
          return;
        }

        this.chapterSwitching = true;
        this._pendingSwitch = {
          frameKey: bufferKey,
          sectionIndex: parsedTarget,
          desiredPage,
          historyMode,
        };
        this._loadSectionIntoFrame(bufferKey, parsedTarget, desiredPage);
      },
      _cleanupTransientQuery() {
        try {
          const url = new URL(window.location.href);
          let changed = false;
          if (url.searchParams.has("page")) {
            url.searchParams.delete("page");
            changed = true;
          }
          if (url.searchParams.has("resume")) {
            url.searchParams.delete("resume");
            changed = true;
          }
          if (url.searchParams.has("nav")) {
            url.searchParams.delete("nav");
            changed = true;
          }
          if (changed) history.replaceState({ section: this.sectionIndex }, "", url);
        } catch {
          // ignore
        }
      },
      init() {
        this._jumpToLast = explicitPageParam === "last";
        this._updateTimeNow();
        this._clockTimer = setInterval(() => this._updateTimeNow(), 30 * 1000);

        const saved = loadSettings();
        if (saved) {
          if (typeof saved.readerBg === "string") this.readerBg = saved.readerBg;
          if (saved.styleMode === "custom") this.styleMode = "custom";
          if (saved.fontFamily && fonts[saved.fontFamily]) this.fontFamily = saved.fontFamily;
          this.fontSize = clampInt(saved.fontSize, 12, 28, 18);
          this.lineHeight = clampFloat(saved.lineHeight, 1.45, 2.2, 1.85);
        }

        const progress = loadProgress(this.bookId);
        const pathSection = this._sectionIndexFromLocation();
        if (Number.isInteger(pathSection) && pathSection >= 0 && pathSection < this.tocCount) {
          this.sectionIndex = pathSection;
        }
        if (resumeRequested && progress && Number.isInteger(progress.section) && progress.section >= 0 && progress.section < this.tocCount) {
          this.sectionIndex = progress.section;
        }
        if (resumeRequested && progress && Number.isInteger(progress.page) && progress.section === this.sectionIndex) {
          this._resumePage = Math.max(1, progress.page);
        }
        if (navReason === "prev" || navReason === "next") {
          this._jumpToLast = false;
          this._resumePage = 1;
        }

        this._bindFrameLoad("a");
        this._bindFrameLoad("b");

        let initialPage = 1;
        if (this._jumpToLast) {
          initialPage = 99999;
        } else if (Number.isInteger(this._resumePage) && this._resumePage > 0) {
          initialPage = this._resumePage;
        }
        this._loadSectionIntoFrame(this.activeFrameKey, this.sectionIndex, initialPage);
        this._updateHistoryForSection(this.sectionIndex, "replace");

        window.addEventListener("keydown", (evt) => this.onKeydown(evt));
        window.addEventListener("resize", () => this.onResize());
        window.addEventListener("beforeunload", () => this._persistProgressNow());
        window.addEventListener("popstate", () => {
          const target = this._sectionIndexFromLocation();
          if (target === null || target === this.sectionIndex) return;
          this.gotoSection(target, { desiredPage: 1, historyMode: "replace" });
        });

        this.$watch("tocOpen", () => {
          if (this.tocOpen) {
            this.settingsOpen = false;
            this._scrollCurrentTocIntoView();
          }
        });

        this.$watch("settingsOpen", () => {
          if (this.settingsOpen) this.tocOpen = false;
        });

        this.$watch("readerBg", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("styleMode", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("fontFamily", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("fontSize", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("lineHeight", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("page", () => this._persistProgressSoon());

        this._scrollCurrentTocIntoView();
        this._persistProgressSoon();
        this._scheduleChapterPreload();
      },
      onResize() {
        if (this._resizeTimer) clearTimeout(this._resizeTimer);
        this._resizeTimer = setTimeout(() => {
          this._applyLayoutWithAnchor();
        }, 150);
      },
      onKeydown(evt) {
        if (!evt) return;
        if (evt.altKey || evt.ctrlKey || evt.metaKey) return;

        if (evt.key === "Escape") {
          if (this.settingsOpen) {
            evt.preventDefault();
            this.settingsOpen = false;
            return;
          }
          if (this.tocOpen) {
            evt.preventDefault();
            this.tocOpen = false;
          }
          return;
        }

        const target = evt.target;
        const tag = target && target.tagName ? String(target.tagName).toLowerCase() : "";
        if (tag === "input" || tag === "textarea" || tag === "select") return;

        if (this.tocOpen || this.settingsOpen) return;

        if (evt.key === "ArrowRight" || evt.key === "PageDown" || evt.key === " ") {
          evt.preventDefault();
          this.pageNext();
          return;
        }
        if (evt.key === "ArrowLeft" || evt.key === "PageUp" || evt.key === "Backspace") {
          evt.preventDefault();
          this.pagePrev();
        }
      },
      canPagePrev() {
        return this.page > 1 || this.sectionIndex > 0;
      },
      canPageNext() {
        return this.page < this.pageCount || this.sectionIndex < this.tocCount - 1;
      },
      pagePrev() {
        const scroller = this.getScroller();
        if (scroller && this.page > 1) {
          this.scrollByPages(-1);
          return;
        }
        if (this.sectionIndex > 0) this.gotoSection(this.sectionIndex - 1, { desiredPage: 1 });
      },
      pageNext() {
        const scroller = this.getScroller();
        if (scroller && this.page < this.pageCount) {
          this.scrollByPages(1);
          return;
        }
        if (this.sectionIndex < this.tocCount - 1) this.gotoSection(this.sectionIndex + 1, { desiredPage: 1 });
      },
      decFont() {
        this.fontSize = Math.max(12, this.fontSize - 1);
      },
      incFont() {
        this.fontSize = Math.min(28, this.fontSize + 1);
      },
      getScroller(frameKey) {
        const frame = frameKey ? this.getFrame(frameKey) : this.getActiveFrame();
        if (!frame || !frame.contentDocument) return null;
        return frame.contentDocument.getElementById("bindery-reader-scroller");
      },
      scrollToPage(targetPage, behavior) {
        const scroller = this.getScroller();
        if (!scroller) return;
        const width = scroller.clientWidth;
        if (width <= 0) return;
        const clamped = Math.max(1, Math.min(this.pageCount, targetPage));
        scroller.scrollTo({ left: (clamped - 1) * width, top: 0, behavior: behavior || "auto" });
        this.page = clamped;
      },
      scrollByPages(delta) {
        const scroller = this.getScroller();
        if (!scroller) return;
        const width = scroller.clientWidth;
        if (width <= 0) return;
        const current = Math.round(scroller.scrollLeft / width) + 1;
        const target = Math.max(1, Math.min(this.pageCount, current + delta));
        this.scrollToPage(target, "auto");
      },
      _computePageMetrics(scroller) {
        const width = scroller.clientWidth;
        if (width <= 0) return null;
        const sw = Math.max(0, scroller.scrollWidth - 1);
        const count = Math.max(1, Math.ceil(sw / width));
        return { width, count };
      },
      _pageFromScroll(scroller, pageCount) {
        const width = scroller.clientWidth || 1;
        const raw = Math.round(scroller.scrollLeft / width) + 1;
        return Math.max(1, Math.min(pageCount, raw));
      },
      refreshPagination(opts) {
        const scroller = this.getScroller();
        if (!scroller) return;
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return;

        this.pageCount = metrics.count;

        if (opts && opts.syncFromScroll) {
          this.page = this._pageFromScroll(scroller, this.pageCount);
          this._persistProgressSoon();
          return;
        }

        const desiredPage = opts && opts.desiredPage ? opts.desiredPage : this.page;
        const behavior = opts && opts.behavior ? opts.behavior : "auto";
        const clamped = Math.max(1, Math.min(this.pageCount, desiredPage));
        this.page = clamped;
        if (!(opts && opts.skipScroll)) {
          scroller.scrollTo({ left: (clamped - 1) * metrics.width, top: 0, behavior: behavior });
        }
        this._persistProgressSoon();
      },
      _onScrollerSettled(scroller, frameKey) {
        if (frameKey !== this.activeFrameKey) return;
        if (!scroller) return;
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return;
        this.pageCount = metrics.count;
        const settled = this._pageFromScroll(scroller, this.pageCount);
        this.page = settled;
        const targetLeft = (settled - 1) * metrics.width;
        if (Math.abs(scroller.scrollLeft - targetLeft) > 1) {
          scroller.scrollTo({ left: targetLeft, top: 0, behavior: "auto" });
        }
        this._persistProgressSoon();
      },
      _attachScrollListener(frameKey) {
        const scroller = this.getScroller(frameKey);
        if (!scroller) return;
        if (scroller.dataset.binderyScrollListener) return;
        scroller.dataset.binderyScrollListener = "1";
        const settle = () => {
          if (frameKey !== this.activeFrameKey) return;
          if (this._scrollEndTimer) clearTimeout(this._scrollEndTimer);
          this._scrollEndTimer = setTimeout(() => this._onScrollerSettled(scroller, frameKey), 90);
        };
        scroller.addEventListener("scroll", settle, { passive: true });
        if ("onscrollend" in scroller) {
          scroller.addEventListener("scrollend", () => this._onScrollerSettled(scroller, frameKey), { passive: true });
        }
      },
      _attachFrameKeyListener(doc) {
        if (!doc || !doc.documentElement) return;
        if (doc.documentElement.dataset.binderyKeyListener) return;
        doc.documentElement.dataset.binderyKeyListener = "1";
        doc.addEventListener("keydown", (evt) => this.onKeydown(evt));
      },
      _mountPagedLayout(doc) {
        if (!doc || !doc.body) return;
        if (doc.getElementById("bindery-reader-scroller")) return;
        const body = doc.body;

        const scroller = doc.createElement("div");
        scroller.id = "bindery-reader-scroller";
        const pages = doc.createElement("div");
        pages.id = "bindery-reader-pages";

        const frag = doc.createDocumentFragment();
        while (body.firstChild) frag.appendChild(body.firstChild);
        pages.appendChild(frag);
        scroller.appendChild(pages);
        body.appendChild(scroller);
      },
      _updateFrameVars(doc, paddingX, paddingY, family, size, lineHeight, themeBg) {
        if (!doc || !doc.body) return;
        doc.documentElement.style.setProperty("--bindery-page-max-width", maxPageWidth + "px");
        doc.documentElement.style.setProperty("--bindery-page-padding-x", paddingX + "px");
        doc.documentElement.style.setProperty("--bindery-page-padding-y", paddingY + "px");
        doc.documentElement.style.setProperty("--bindery-font-family", family);
        doc.documentElement.style.setProperty("--bindery-font-size", size + "px");
        doc.documentElement.style.setProperty("--bindery-line-height", String(lineHeight));
        doc.documentElement.style.setProperty("--bindery-reader-bg", themeBg);

        const scroller = doc.getElementById("bindery-reader-scroller");
        if (!scroller) return;
        const width = scroller.clientWidth || maxPageWidth;
        const columnWidth = Math.max(240, width - 2 * paddingX);
        const columnGap = paddingX > 0 ? Math.max(6, Math.round(paddingX * 1.1)) : 0;
        doc.documentElement.style.setProperty("--bindery-column-width", columnWidth + "px");
        doc.documentElement.style.setProperty("--bindery-column-gap", columnGap + "px");

        const pages = doc.getElementById("bindery-reader-pages");
        if (this.styleMode === "custom") {
          doc.body.style.setProperty("font-family", family, "important");
          doc.body.style.setProperty("font-size", size + "px", "important");
          doc.body.style.setProperty("line-height", String(lineHeight), "important");
          if (pages) {
            pages.style.setProperty("font-family", family, "important");
            pages.style.setProperty("font-size", size + "px", "important");
            pages.style.setProperty("line-height", String(lineHeight), "important");
          }
        } else {
          doc.body.style.removeProperty("font-family");
          doc.body.style.removeProperty("font-size");
          doc.body.style.removeProperty("line-height");
          if (pages) {
            pages.style.removeProperty("font-family");
            pages.style.removeProperty("font-size");
            pages.style.removeProperty("line-height");
          }
        }
      },
      _serializeNodePath(doc, node) {
        if (!doc || !node) return null;
        const path = [];
        let cursor = node;
        while (cursor && cursor !== doc.documentElement) {
          const parent = cursor.parentNode;
          if (!parent || !parent.childNodes) return null;
          const siblings = parent.childNodes;
          let index = -1;
          for (let i = 0; i < siblings.length; i += 1) {
            if (siblings[i] === cursor) {
              index = i;
              break;
            }
          }
          if (index < 0) return null;
          path.push(index);
          cursor = parent;
        }
        if (cursor !== doc.documentElement) return null;
        return path.reverse();
      },
      _resolveNodePath(doc, path) {
        if (!doc || !Array.isArray(path)) return null;
        let cursor = doc.documentElement;
        for (const index of path) {
          if (!cursor || !cursor.childNodes || index < 0 || index >= cursor.childNodes.length) return null;
          cursor = cursor.childNodes[index];
        }
        return cursor || null;
      },
      _getCaretPosition(doc, x, y) {
        if (doc && typeof doc.caretPositionFromPoint === "function") {
          const pos = doc.caretPositionFromPoint(x, y);
          if (pos && pos.offsetNode) {
            return { node: pos.offsetNode, offset: Number(pos.offset) || 0 };
          }
        }
        if (doc && typeof doc.caretRangeFromPoint === "function") {
          const range = doc.caretRangeFromPoint(x, y);
          if (range && range.startContainer) {
            return { node: range.startContainer, offset: Number(range.startOffset) || 0 };
          }
        }
        return null;
      },
      _captureViewportAnchor(doc) {
        const scroller = doc && doc.getElementById ? doc.getElementById("bindery-reader-scroller") : null;
        if (!scroller) return null;
        const rect = scroller.getBoundingClientRect();
        const x = rect.left + Math.min(24, Math.max(8, rect.width * 0.05));
        const y = rect.top + Math.min(24, Math.max(8, rect.height * 0.05));
        const caret = this._getCaretPosition(doc, x, y);
        if (!caret || !caret.node) return null;
        const path = this._serializeNodePath(doc, caret.node);
        if (!path) return null;
        return {
          path,
          offset: Math.max(0, Number(caret.offset) || 0),
        };
      },
      _restoreViewportAnchor(doc, anchor) {
        if (!doc || !anchor || !Array.isArray(anchor.path)) return false;
        const scroller = doc.getElementById("bindery-reader-scroller");
        if (!scroller) return false;

        let targetNode = this._resolveNodePath(doc, anchor.path);
        if (!targetNode) return false;
        let targetOffset = Math.max(0, Number(anchor.offset) || 0);

        if (targetNode.nodeType !== 3) {
          const walker = doc.createTreeWalker(targetNode, 4);
          const textNode = walker.nextNode();
          if (!textNode) return false;
          targetNode = textNode;
          targetOffset = 0;
        } else {
          const length = targetNode.textContent ? targetNode.textContent.length : 0;
          targetOffset = Math.min(targetOffset, Math.max(0, length));
        }

        const range = doc.createRange();
        range.setStart(targetNode, targetOffset);
        range.collapse(true);
        const rect = range.getBoundingClientRect();
        if (!rect) return false;

        const scrollerRect = scroller.getBoundingClientRect();
        const deltaX = rect.left - scrollerRect.left - 8;
        const nextLeft = Math.max(0, scroller.scrollLeft + deltaX);
        scroller.scrollTo({ left: nextLeft, top: 0, behavior: "auto" });
        return true;
      },
      applyToFrame(opts) {
        const frameKey = (opts && opts.frameKey) || this.activeFrameKey;
        if (this._frameApplying[frameKey]) return;
        const frame = this.getFrame(frameKey);
        if (!frame || !frame.contentDocument) return;
        const doc = frame.contentDocument;
        const head = doc.head || doc.getElementsByTagName("head")[0];
        if (!head) return;
        if (!doc.body) return;
        this._frameApplying[frameKey] = true;
        const preserveAnchor = !!(opts && opts.preserveAnchor && frameKey === this.activeFrameKey && this._frameApplied[frameKey]);
        const anchor = preserveAnchor ? this._captureViewportAnchor(doc) : null;

        this._mountPagedLayout(doc);

        let style = doc.getElementById("bindery-reader-style");
        if (!style) {
          style = doc.createElement("style");
          style.id = "bindery-reader-style";
          head.appendChild(style);
        }

        const family = fonts[this.fontFamily] || fonts.serif;
        const size = clampInt(this.fontSize, 12, 28, 18);
        const lineHeight = clampFloat(this.lineHeight, 1.45, 2.2, 1.85);
        const paddingX = this.styleMode === "custom" ? 10 : 0;
        const paddingY = this.styleMode === "custom" ? 12 : 0;
        const themeOn = this.readerBg !== "book";
        const themeBg = bgColors[this.readerBg] || bgColors.slate;

        doc.documentElement.classList.toggle("bindery-mode-custom", this.styleMode === "custom");
        doc.documentElement.classList.toggle("bindery-mode-book", this.styleMode !== "custom");
        doc.documentElement.classList.toggle("bindery-theme-on", themeOn);

        style.textContent =
          "html,body{height:100%!important;}" +
          "body{overflow:hidden!important;}" +
          "html.bindery-theme-on,html.bindery-theme-on body{background:var(--bindery-reader-bg)!important;}" +
          "html.bindery-mode-custom body{font-family:var(--bindery-font-family)!important;font-size:var(--bindery-font-size)!important;line-height:var(--bindery-line-height,1.85)!important;}" +
          "html.bindery-mode-custom #bindery-reader-pages,html.bindery-mode-custom #bindery-reader-pages p,html.bindery-mode-custom #bindery-reader-pages li,html.bindery-mode-custom #bindery-reader-pages div,html.bindery-mode-custom #bindery-reader-pages span,html.bindery-mode-custom #bindery-reader-pages blockquote,html.bindery-mode-custom #bindery-reader-pages td,html.bindery-mode-custom #bindery-reader-pages th{font-family:var(--bindery-font-family)!important;font-size:var(--bindery-font-size)!important;line-height:var(--bindery-line-height,1.85)!important;}" +
          "#bindery-reader-scroller{height:100%!important;width:100%!important;max-width:var(--bindery-page-max-width,600px)!important;margin:0 auto!important;overflow-x:auto!important;overflow-y:hidden!important;scroll-behavior:auto!important;scroll-snap-type:x mandatory;overscroll-behavior-x:contain;scrollbar-width:none;}" +
          "#bindery-reader-scroller::-webkit-scrollbar{display:none;}" +
          "#bindery-reader-pages{height:100%!important;box-sizing:border-box!important;column-fill:auto;column-gap:var(--bindery-column-gap,0px);column-width:var(--bindery-column-width,480px);padding:var(--bindery-page-padding-y,0px) var(--bindery-page-padding-x,0px)!important;scroll-snap-align:start;}" +
          "h1,h2,h3,h4,h5,h6,pre,blockquote,figure,table{break-inside:avoid-column;}" +
          "img,svg,video{max-width:100%!important;height:auto!important;}";

        requestAnimationFrame(() => {
          try {
            this._updateFrameVars(doc, paddingX, paddingY, family, size, lineHeight, themeBg);
            this._attachScrollListener(frameKey);
            this._attachFrameKeyListener(doc);

            let desired = Number.isInteger(opts && opts.desiredPage) ? opts.desiredPage : this.page;
            if (desired <= 0) desired = 1;
            if (preserveAnchor && anchor) {
              this.refreshPagination({ syncFromScroll: true });
              const restored = this._restoreViewportAnchor(doc, anchor);
              if (restored) {
                this.refreshPagination({ syncFromScroll: true });
              } else {
                this.refreshPagination({ desiredPage: desired, behavior: "auto" });
              }
            } else {
              if (opts && opts.primeOnly) {
                const scroller = this.getScroller(frameKey);
                const metrics = scroller ? this._computePageMetrics(scroller) : null;
                if (scroller && metrics) {
                  const clamped = Math.max(1, Math.min(metrics.count, desired));
                  scroller.scrollTo({ left: (clamped - 1) * metrics.width, top: 0, behavior: "auto" });
                }
              } else {
                this.refreshPagination({ desiredPage: desired, behavior: "auto" });
              }
            }
            this._jumpToLast = false;
            this._resumePage = null;
            this._frameApplied[frameKey] = true;
            this._cleanupTransientQuery();
          } finally {
            this._frameApplying[frameKey] = false;
            if (opts && typeof opts.onDone === "function") opts.onDone();
          }
        });
      },
    };
  }
</script>
{% endblock %}
