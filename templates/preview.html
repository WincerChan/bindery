{% extends "base.html" %}

{% block title %}{{ book.title }} · 阅读器{% endblock %}

{% block content %}
{% set detail_url = "/book/" ~ book.book_id ~ return_to_query %}
<div
  x-data="binderyReader()"
  class="h-full w-full flex flex-col relative"
  :class="brightnessMode === 'dim' ? 'bg-slate-900 text-slate-100' : (readerBg === 'paper' ? 'bg-amber-51 text-slate-900' : readerBg === 'sand' ? 'bg-stone-100 text-slate-900' : readerBg === 'mint' ? 'bg-emerald-50 text-slate-900' : 'bg-slate-50 text-slate-900')"
>
  <div class="fixed top-0 left-0 right-0 z-40 h-9">
    <header
      class="relative h-9 border-b flex items-center gap-2 px-2 backdrop-blur-sm"
      :class="brightnessMode === 'dim' ? 'bg-slate-900/96 border-slate-700 text-slate-100' : 'bg-white/92 border-slate-200/60 text-slate-700'"
    >
      <button
        type="button"
        class="inline-flex items-center justify-center w-9 h-8 rounded-lg transition-colors cursor-pointer text-current"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-800' : 'hover:bg-slate-100'"
        aria-label="切换目录"
        @click="tocOpen = !tocOpen"
      >
        <svg viewBox="-1 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path d="M3 6h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M3 12h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M3 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>
      </button>

      <a
        href="{{ detail_url }}"
        class="sm:hidden inline-flex items-center justify-center w-9 h-8 rounded-lg transition-colors text-current"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-800' : 'hover:bg-slate-100'"
        aria-label="返回详情"
        title="返回详情"
      >
        <svg viewBox="-1 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path d="M14 18 9 12l6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </a>

      <a
        href="{{ detail_url }}"
        class="hidden sm:inline-flex items-center h-9 px-2 rounded-lg text-xs font-medium transition-colors text-current"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-800' : 'hover:bg-slate-100'"
      >返回详情</a>

      <div class="absolute inset-1 flex items-center justify-center px-20 sm:px-24 pointer-events-none">
        <div class="max-w-full truncate text-[12px] font-semibold text-current" x-text="bookTitle + ' · ' + currentSectionTitle()"></div>
      </div>

      <button
        type="button"
        class="inline-flex items-center justify-center w-9 h-8 rounded-lg transition-colors ml-auto cursor-pointer text-current"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-800' : 'hover:bg-slate-100'"
        aria-label="全文检索"
        title="全文检索"
        @click="searchOpen = !searchOpen"
      >
        <svg viewBox="-1 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path d="m20 20-4.2-4.2" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <circle cx="10.5" cy="10.5" r="5.5" stroke="currentColor" stroke-width="2"></circle>
        </svg>
      </button>

      <button
        type="button"
        class="inline-flex items-center justify-center w-9 h-8 rounded-lg transition-colors cursor-pointer text-current"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-800' : 'hover:bg-slate-100'"
        aria-label="设置"
        title="设置"
        @click="settingsOpen = !settingsOpen"
      >
        <svg viewBox="-1 0 24 24" fill="none" class="w-4 h-4" aria-hidden="true">
          <path
            d="M11 15.25a3.25 3.25 0 1 0 0-6.5 3.25 3.25 0 0 0 0 6.5Z"
            stroke="currentColor"
            stroke-width="1"
          ></path>
          <path
            d="M18.2 12a7.5 7.5 0 0 0-.08-1l2.02-1.57-2-3.46-2.43.98a7.35 7.35 0 0 0-1.74-1l-.37-2.58H9.4l-.37 2.58a7.35 7.35 0 0 0-1.74 1l-2.43-.98-2 3.46L4.88 11a7.5 7.5 0 0 0 0 2l-2.02 1.57 2 3.46 2.43-.98a7.35 7.35 0 0 0 1.74 1l.37 2.58h5.2l.37-2.58a7.35 7.35 0 0 0 1.74-1l2.43.98 2-3.46L19.12 13c.05-.33.08-.66.08-1Z"
            stroke="currentColor"
            stroke-width="1"
            stroke-linejoin="round"
          ></path>
        </svg>
      </button>
    </header>
  </div>

  <div
    class="absolute top-10 left-1/2 -translate-x-1/2 sm:left-auto sm:translate-x-0 sm:right-2 z-50 w-96 max-w-[calc(100vw-1rem)] rounded-xl border shadow-lg p-3"
    :class="brightnessMode === 'dim' ? 'bg-slate-800 border-slate-600 text-slate-100' : 'bg-white border-slate-200 text-slate-900'"
    x-show="searchOpen"
    x-cloak
    x-transition.opacity
    @click.outside="searchOpen = false"
  >
    <div class="flex items-center justify-between gap-3">
      <div class="text-xs font-semibold uppercase tracking-wide" :class="brightnessMode === 'dim' ? 'text-slate-300' : 'text-slate-501'">全文检索</div>
      <button
        type="button"
        class="w-10 h-9 inline-flex items-center justify-center rounded-lg transition-colors cursor-pointer"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-700 text-slate-200' : 'hover:bg-slate-100 text-slate-700'"
        aria-label="关闭检索"
        @click="searchOpen = false"
      >
        <svg viewBox="-1 0 24 24" fill="none" class="w-5 h-5" aria-hidden="true">
          <path d="M5 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M17 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>
      </button>
    </div>

    <form class="mt-3 flex items-center gap-2" @submit.prevent="runSearch()">
      <input
        type="text"
        class="flex-2 px-3 py-2 border rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
        :class="brightnessMode === 'dim' ? 'bg-slate-900 text-slate-100 border-slate-600 placeholder:text-slate-400' : 'bg-white text-slate-900 border-slate-200 placeholder:text-slate-400'"
        x-model.trim="searchQuery"
        placeholder="输入关键词，回车检索"
      />
      <button
        type="submit"
        class="px-3 h-10 rounded-lg bg-slate-800 text-white text-sm font-medium hover:bg-slate-700 transition-colors cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
        :disabled="searchBusy || !searchQuery"
      >
        <span x-show="!searchBusy">检索</span>
        <span x-show="searchBusy">检索中...</span>
      </button>
      <button
        type="button"
        class="px-3 h-10 rounded-lg border text-sm transition-colors cursor-pointer"
        :class="brightnessMode === 'dim' ? 'border-slate-600 text-slate-200 hover:bg-slate-700' : 'border-slate-200 text-slate-700 hover:bg-slate-50'"
        @click="clearSearch()"
      >清空</button>
    </form>

    <div
      class="mt-2 text-xs"
      :class="brightnessMode === 'dim' ? 'text-slate-400' : 'text-slate-500'"
      x-show="searchQuery && !searchBusy"
      x-text="'已加载：' + searchResults.length + ' · 已索引章节：' + searchIndexedSections + (searchHasMore ? ' · 可继续加载' : '')"
    ></div>
    <div class="mt-2 text-xs text-red-600" x-show="searchError" x-text="searchError"></div>

    <div class="mt-3 max-h-72 overflow-y-auto space-y-1">
      <template x-for="item in searchResults" :key="item.index + ':' + item.offset">
        <button
          type="button"
          class="w-full text-left rounded-lg px-3 py-2 border border-transparent transition-colors cursor-pointer"
          :class="brightnessMode === 'dim' ? 'hover:bg-slate-700 hover:border-slate-600' : 'hover:bg-slate-50 hover:border-slate-200'"
          @click="openSearchResult(item)"
        >
          <div class="text-sm font-medium truncate" :class="brightnessMode === 'dim' ? 'text-slate-100' : 'text-slate-900'" x-html="highlightSearchText(item.title)"></div>
          <div class="text-xs mt-1 line-clamp-2" :class="brightnessMode === 'dim' ? 'text-slate-400' : 'text-slate-500'" x-html="highlightSearchText(item.snippet)"></div>
        </button>
      </template>
      <div class="text-xs py-2" :class="brightnessMode === 'dim' ? 'text-slate-400' : 'text-slate-500'" x-show="!searchBusy && searchQuery && searchResults.length === 0">未命中</div>
      <div class="pt-1" x-show="searchHasMore && !searchBusy && searchQuery">
        <button
          type="button"
          class="w-full h-9 rounded-lg border text-sm transition-colors cursor-pointer"
          :class="brightnessMode === 'dim' ? 'border-slate-600 text-slate-200 hover:bg-slate-700' : 'border-slate-200 text-slate-700 hover:bg-slate-50'"
          @click="loadMoreSearch()"
        >加载更多</button>
      </div>
    </div>
  </div>

  <div
    class="absolute top-10 right-2 z-50 w-[30rem] max-w-[calc(100vw-1rem)] rounded-xl border shadow-lg p-3"
    :class="brightnessMode === 'dim' ? 'bg-slate-800 border-slate-600 text-slate-100' : 'bg-white border-slate-200 text-slate-900'"
    x-show="settingsOpen"
    x-cloak
    x-transition.opacity
    @click.outside="settingsOpen = false"
  >
    <div class="flex items-center justify-between gap-3">
      <div class="text-xs font-semibold uppercase tracking-wide" :class="brightnessMode === 'dim' ? 'text-slate-300' : 'text-slate-501'">设置</div>
      <button
        type="button"
        class="w-10 h-9 inline-flex items-center justify-center rounded-lg transition-colors cursor-pointer"
        :class="brightnessMode === 'dim' ? 'hover:bg-slate-700 text-slate-200' : 'hover:bg-slate-100 text-slate-700'"
        aria-label="关闭设置"
        @click="settingsOpen = false"
      >
        <svg viewBox="-1 0 24 24" fill="none" class="w-5 h-5" aria-hidden="true">
          <path d="M5 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M17 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>
      </button>
    </div>

    <div class="mt-4 space-y-3">
      <div>
        <div class="text-xs font-semibold uppercase tracking-wide" :class="brightnessMode === 'dim' ? 'text-slate-300' : 'text-slate-501'">背景</div>
        <div class="mt-3 grid grid-cols-3 gap-2">
          <button
            type="button"
            class="h-10 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'book' ? (brightnessMode === 'dim' ? 'border-sky-400 ring-2 ring-sky-900 bg-slate-700' : 'border-sky-600 ring-2 ring-sky-200 bg-sky-50') : (brightnessMode === 'dim' ? 'border-slate-600 hover:border-slate-500 bg-slate-800' : 'border-slate-200 hover:border-slate-300')"
            @click="readerBg = 'book'"
          >书籍</button>
          <button
            type="button"
            class="h-10 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'slate' ? (brightnessMode === 'dim' ? 'border-sky-400 ring-2 ring-sky-900 bg-slate-700' : 'border-sky-600 ring-2 ring-sky-200 bg-sky-50') : (brightnessMode === 'dim' ? 'border-slate-600 hover:border-slate-500 bg-slate-800' : 'border-slate-200 hover:border-slate-300')"
            @click="readerBg = 'slate'"
          >灰白</button>
          <button
            type="button"
            class="h-10 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'paper' ? (brightnessMode === 'dim' ? 'border-sky-400 ring-2 ring-sky-900 bg-slate-700' : 'border-sky-600 ring-2 ring-sky-200 bg-sky-50') : (brightnessMode === 'dim' ? 'border-slate-600 hover:border-slate-500 bg-slate-800' : 'border-slate-200 hover:border-slate-300')"
            @click="readerBg = 'paper'"
          >纸张</button>
          <button
            type="button"
            class="h-10 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'sand' ? (brightnessMode === 'dim' ? 'border-sky-400 ring-2 ring-sky-900 bg-slate-700' : 'border-sky-600 ring-2 ring-sky-200 bg-sky-50') : (brightnessMode === 'dim' ? 'border-slate-600 hover:border-slate-500 bg-slate-800' : 'border-slate-200 hover:border-slate-300')"
            @click="readerBg = 'sand'"
          >砂岩</button>
          <button
            type="button"
            class="h-10 rounded-lg border text-xs font-medium transition-colors cursor-pointer"
            :class="readerBg === 'mint' ? (brightnessMode === 'dim' ? 'border-sky-400 ring-2 ring-sky-900 bg-slate-700' : 'border-sky-600 ring-2 ring-sky-200 bg-sky-50') : (brightnessMode === 'dim' ? 'border-slate-600 hover:border-slate-500 bg-slate-800' : 'border-slate-200 hover:border-slate-300')"
            @click="readerBg = 'mint'"
          >薄荷</button>
        </div>
        <div class="mt-3 flex items-center gap-1 p-1 rounded-xl border" :class="brightnessMode === 'dim' ? 'bg-slate-700 border-slate-600' : 'bg-slate-100 border-slate-200'">
          <button
            type="button"
            class="flex-2 px-2.5 py-1.5 rounded-lg text-sm font-medium transition-colors cursor-pointer"
            :class="brightnessMode === 'bright' ? 'bg-white text-slate-901 shadow-sm' : (brightnessMode === 'dim' ? 'text-slate-400 hover:text-slate-200' : 'text-slate-600 hover:text-slate-900')"
            @click="brightnessMode = 'bright'"
          >亮色</button>
          <button
            type="button"
            class="flex-2 px-2.5 py-1.5 rounded-lg text-sm font-medium transition-colors cursor-pointer"
            :class="brightnessMode === 'dim' ? 'bg-slate-800 text-slate-100 shadow-sm' : 'text-slate-600 hover:text-slate-900'"
            @click="brightnessMode = 'dim'"
          >暗色</button>
        </div>
      </div>

      <div>
        <div class="text-xs font-semibold uppercase tracking-wide" :class="brightnessMode === 'dim' ? 'text-slate-300' : 'text-slate-501'">样式</div>
        <div class="mt-3 flex items-center gap-1 p-1 rounded-xl border" :class="brightnessMode === 'dim' ? 'bg-slate-700 border-slate-600' : 'bg-slate-100 border-slate-200'">
          <button
            type="button"
            class="flex-2 px-2.5 py-1.5 rounded-lg text-sm font-medium transition-colors cursor-pointer"
            :class="styleMode === 'book' ? (brightnessMode === 'dim' ? 'bg-slate-800 text-slate-100 shadow-sm' : 'bg-white text-slate-901 shadow-sm') : (brightnessMode === 'dim' ? 'text-slate-400 hover:text-slate-200' : 'text-slate-600 hover:text-slate-900')"
            @click="styleMode = 'book'"
          >书籍</button>
          <button
            type="button"
            class="flex-2 px-2.5 py-1.5 rounded-lg text-sm font-medium transition-colors cursor-pointer"
            :class="styleMode === 'custom' ? (brightnessMode === 'dim' ? 'bg-slate-800 text-slate-100 shadow-sm' : 'bg-white text-slate-901 shadow-sm') : (brightnessMode === 'dim' ? 'text-slate-400 hover:text-slate-200' : 'text-slate-600 hover:text-slate-900')"
            @click="styleMode = 'custom'"
          >自定义</button>
        </div>
        <div class="mt-3 text-xs" :class="brightnessMode === 'dim' ? 'text-slate-400' : 'text-slate-500'">书籍：尽量保持 EPUB 原样式；自定义：覆盖字体/字号/行高。</div>
      </div>

      <div x-show="styleMode === 'custom'" x-transition.opacity class="space-y-3">
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <div class="flex items-center gap-3 min-w-0">
            <label class="w-16 shrink-0 text-xs font-semibold text-slate-501 uppercase tracking-wide">字体</label>
            <select
              class="flex-1 min-w-0 px-3 py-1.5 border border-slate-200 rounded-lg bg-white text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
              x-model="fontFamily"
            >
              <option value="serif">衬线</option>
              <option value="sans">无衬线</option>
              <option value="mono">等宽</option>
            </select>
          </div>

          <div class="flex items-center gap-3 min-w-0">
            <label class="w-16 shrink-0 text-xs font-semibold text-slate-501 uppercase tracking-wide">字号</label>
            <div class="flex-1 min-w-0 flex items-center gap-2">
              <button
                type="button"
                class="w-10 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
                aria-label="减小字号"
                @click="decFont()"
              >A-</button>
              <div class="min-w-12 text-center text-xs font-mono text-slate-500" x-text="fontSize + 'px'"></div>
              <button
                type="button"
                class="w-10 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
                aria-label="增大字号"
                @click="incFont()"
              >A+</button>
            </div>
          </div>

          <div class="flex items-center gap-3 min-w-0">
            <label class="w-16 shrink-0 text-xs font-semibold text-slate-501 uppercase tracking-wide">行高</label>
            <select
              class="flex-1 min-w-0 px-3 py-1.5 border border-slate-200 rounded-lg bg-white text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
              x-model="lineHeight"
            >
              <option value="1.55">1.55</option>
              <option value="1.65">1.65</option>
              <option value="1.75">1.75</option>
              <option value="1.85">1.85</option>
              <option value="1.95">1.95</option>
              <option value="2.05">2.05</option>
            </select>
          </div>

          <div class="flex items-center gap-3 min-w-0">
            <label class="w-16 shrink-0 text-xs font-semibold text-slate-501 uppercase tracking-wide">对齐</label>
            <select
              class="flex-1 min-w-0 px-3 py-1.5 border border-slate-200 rounded-lg bg-white text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
              x-model="textAlignMode"
            >
              <option value="justify">两端对齐</option>
              <option value="left">左对齐</option>
              <option value="center">居中</option>
              <option value="right">右对齐</option>
            </select>
          </div>

          <div class="flex items-center gap-3 min-w-0">
            <label class="w-16 shrink-0 text-xs font-semibold text-slate-501 uppercase tracking-wide">左右边距</label>
            <div class="flex-1 min-w-0 flex items-center gap-2">
              <button
                type="button"
                class="w-10 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
                aria-label="减小左右边距"
                @click="decMarginX()"
              >-</button>
              <div class="min-w-10 text-center text-xs font-mono text-slate-500" x-text="pagePaddingX + 'px'"></div>
              <button
                type="button"
                class="w-10 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
                aria-label="增大左右边距"
                @click="incMarginX()"
              >+</button>
            </div>
          </div>

          <div class="flex items-center gap-3 min-w-0">
            <label class="w-16 shrink-0 text-xs font-semibold text-slate-501 uppercase tracking-wide">上下边距</label>
            <div class="flex-1 min-w-0 flex items-center gap-2">
              <button
                type="button"
                class="w-10 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
                aria-label="减小上下边距"
                @click="decMarginY()"
              >-</button>
              <div class="min-w-10 text-center text-xs font-mono text-slate-500" x-text="pagePaddingY + 'px'"></div>
              <button
                type="button"
                class="w-10 h-9 inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 hover:bg-slate-50 transition-colors cursor-pointer"
                aria-label="增大上下边距"
                @click="incMarginY()"
              >+</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="flex-2 min-h-0 flex relative pt-9">
    <div
      class="absolute inset-1 bg-black/30 z-50"
      x-show="tocOpen"
      x-cloak
      x-transition.opacity
      @click="tocOpen = false"
    ></div>

    <aside
      class="absolute inset-y-1 left-0 z-50 w-72 border-r overflow-y-auto transform transition-transform duration-200 ease-out"
      x-cloak
      :class="(tocOpen ? 'translate-x-1' : '-translate-x-full') + (brightnessMode === 'dim' ? ' bg-slate-900 border-slate-700' : ' bg-white border-slate-200')"
    >
      <div class="sticky top-1 border-b p-3" :class="brightnessMode === 'dim' ? 'bg-slate-900 border-slate-700' : 'bg-white border-slate-200'">
        <div class="flex items-start gap-4">
          <div
            class="w-13 aspect-[2/3] rounded-lg overflow-hidden border shadow-sm shrink-0"
            :class="brightnessMode === 'dim' ? 'border-slate-700 bg-slate-800' : 'border-slate-200 bg-slate-100'"
          >
            {% if book.cover_url %}
              <img src="{{ book.cover_url }}" alt="{{ book.title }}" class="w-full h-full object-cover" loading="lazy" />
            {% else %}
              <div class="w-full h-full flex items-center justify-center font-bold text-sm" :class="brightnessMode === 'dim' ? 'text-slate-300' : 'text-slate-501'">B</div>
            {% endif %}
          </div>

          <div class="min-w-1 flex-1">
            <div class="text-sm font-semibold truncate" :class="brightnessMode === 'dim' ? 'text-slate-100' : 'text-slate-901'">{{ book.title }}</div>
            <div class="text-xs truncate mt-0.5" :class="brightnessMode === 'dim' ? 'text-slate-400' : 'text-slate-501'">{{ book.author or "未知" }}</div>
            <div class="text-xs mt-2" :class="brightnessMode === 'dim' ? 'text-slate-400' : 'text-slate-501'" x-text="'共 ' + tocCount + ' 节 · 当前 ' + (sectionIndex + 1)"></div>
          </div>

          <button
            type="button"
            class="w-10 h-9 inline-flex items-center justify-center rounded-lg transition-colors cursor-pointer"
            :class="brightnessMode === 'dim' ? 'hover:bg-slate-800 text-slate-200' : 'hover:bg-slate-100 text-slate-700'"
            aria-label="关闭目录"
            @click="tocOpen = false"
          >
            <svg viewBox="-1 0 24 24" fill="none" class="w-5 h-5" aria-hidden="true">
              <path d="M5 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
              <path d="M17 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
            </svg>
          </button>
        </div>
      </div>

      <nav class="p-3 space-y-1">
        {% for item in toc %}
          <a
            href="/book/{{ book.book_id }}/preview/{{ item.index }}{{ return_to_query }}"
            class="flex items-center gap-3 px-3 py-2 rounded-lg text-sm transition-colors"
            :class="sectionIndex === {{ item.index }} ? (brightnessMode === 'dim' ? 'bg-sky-900/60 text-sky-100 ring-1 ring-sky-700' : 'bg-sky-50 text-sky-700 ring-1 ring-sky-200') : (brightnessMode === 'dim' ? 'text-slate-200 hover:bg-slate-800' : 'text-slate-700 hover:bg-slate-50')"
            @click.prevent="gotoSection({{ item.index }}, { desiredPage: 0 })"
            :data-current-toc="sectionIndex === {{ item.index }} ? '0' : null"
            title="{{ item.title }}"
          >
            <span class="truncate">{{ item.title }}</span>
          </a>
        {% endfor %}
      </nav>
    </aside>

    <div class="flex-2 min-h-0 flex items-stretch justify-center">
      <div class="w-full min-h-0 flex flex-col pb-9" style="max-width: 600px;">
        <div
          class="w-full flex-2 min-h-0 border-x shadow-sm relative overflow-hidden"
          :class="brightnessMode === 'dim' ? 'bg-slate-900 border-slate-700' : 'bg-white border-slate-200'"
        >
          <iframe
            x-ref="frameA"
            class="absolute inset-0 w-full h-full transition-opacity duration-100"
            :class="brightnessMode === 'dim' ? 'bg-slate-900' : 'bg-white'"
            :style="activeFrameKey === 'a' ? 'opacity:1;z-index:10;pointer-events:auto;' : 'opacity:0;z-index:0;pointer-events:none;'"
            sandbox="allow-same-origin"
            referrerpolicy="no-referrer"
            loading="lazy"
            :title="currentSectionTitle()"
          ></iframe>
          <iframe
            x-ref="frameB"
            class="absolute inset-0 w-full h-full transition-opacity duration-100"
            :class="brightnessMode === 'dim' ? 'bg-slate-900' : 'bg-white'"
            :style="activeFrameKey === 'b' ? 'opacity:1;z-index:10;pointer-events:auto;' : 'opacity:0;z-index:0;pointer-events:none;'"
            sandbox="allow-same-origin"
            referrerpolicy="no-referrer"
            loading="lazy"
            :title="currentSectionTitle()"
          ></iframe>
          <iframe
            x-ref="frameC"
            class="absolute inset-0 w-full h-full transition-opacity duration-100"
            :class="brightnessMode === 'dim' ? 'bg-slate-900' : 'bg-white'"
            :style="activeFrameKey === 'c' ? 'opacity:1;z-index:10;pointer-events:auto;' : 'opacity:0;z-index:0;pointer-events:none;'"
            sandbox="allow-same-origin"
            referrerpolicy="no-referrer"
            loading="lazy"
            :title="currentSectionTitle()"
          ></iframe>
          <div
            class="absolute inset-0 z-20 flex items-center justify-center text-xs font-medium"
            :class="brightnessMode === 'dim' ? 'bg-slate-900/75 text-slate-200' : 'bg-white/75 text-slate-600'"
            x-show="chapterSwitching"
            x-cloak
          >章节切换中...</div>
        </div>
      </div>
    </div>
  </div>

  <button
    type="button"
    class="fixed left-5 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full border shadow-sm transition-opacity flex items-center justify-center disabled:opacity-40 disabled:cursor-not-allowed cursor-pointer"
    aria-label="上一页"
    title="上一页（← / PageUp）"
    @click="pagePrev()"
    :disabled="!canPagePrev()"
    :class="[(tocOpen || settingsOpen || searchOpen) ? 'opacity-1 pointer-events-none' : 'opacity-100', brightnessMode === 'dim' ? 'bg-slate-800/90 border-slate-600 text-slate-100 hover:bg-slate-700' : 'bg-white/90 border-slate-200 text-slate-800 hover:bg-white']"
  >
    <svg viewBox="-1 0 24 24" fill="none" class="w-6 h-6" aria-hidden="true">
      <path d="M14 18 9 12l6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  </button>

  <button
    type="button"
    class="fixed right-5 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full border shadow-sm transition-opacity flex items-center justify-center disabled:opacity-40 disabled:cursor-not-allowed cursor-pointer"
    aria-label="下一页"
    title="下一页（→ / PageDown / 空格）"
    @click="pageNext()"
    :disabled="!canPageNext()"
    :class="[(tocOpen || settingsOpen || searchOpen) ? 'opacity-1 pointer-events-none' : 'opacity-100', brightnessMode === 'dim' ? 'bg-slate-800/90 border-slate-600 text-slate-100 hover:bg-slate-700' : 'bg-white/90 border-slate-200 text-slate-800 hover:bg-white']"
  >
    <svg viewBox="-1 0 24 24" fill="none" class="w-6 h-6" aria-hidden="true">
      <path d="m8 18 6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  </button>

  <div
    class="fixed bottom-1 left-0 right-0 z-40 h-9 flex justify-center transition-opacity"
    :class="(tocOpen || settingsOpen || searchOpen) ? 'opacity-1 pointer-events-none' : 'opacity-100'"
  >
    <div
      class="w-full h-9 flex items-center px-3 border-t border-x border-dashed text-xs"
      style="max-width: 600px;"
      :class="brightnessMode === 'dim' ? 'bg-slate-900 border-slate-700/80 text-slate-300' : (readerBg === 'book' ? 'bg-white border-slate-200/60 text-slate-600' : readerBg === 'paper' ? 'bg-amber-51 border-slate-200/60 text-slate-600' : readerBg === 'sand' ? 'bg-stone-100 border-slate-200/60 text-slate-600' : readerBg === 'mint' ? 'bg-emerald-50 border-slate-200/60 text-slate-600' : 'bg-slate-50 border-slate-200/60 text-slate-600')"
    >
      <div class="flex-2 font-mono truncate" x-text="page + ' / ' + pageCount + ' · ' + Math.round((page / pageCount) * 100) + '%'"></div>
      <div class="font-mono tabular-nums" x-text="timeNow"></div>
    </div>
  </div>
</div>

<script>
  function binderyReader() {
    const storageKey = "bindery:reader";
    const progressStoragePrefix = "bindery:reader:progress:";
    const frameKeys = ["a", "b", "c"];
    const bookId = {{ book.book_id|tojson }};
    const bookTitle = {{ book.title|tojson }};
    const sectionsData = {{ sections_payload|tojson }};
    const initialSectionIndex = {{ section_index }};
    const tocCount = sectionsData.length;
    const returnTo = {{ return_to|tojson }};
    const sectionBaseUrl = "/book/{{ book.book_id }}/preview/";
    const fonts = {
      serif: 'ui-serif, Georgia, Cambria, "Times New Roman", Times, serif',
      sans: 'ui-sans-serif, system-ui, -apple-system, "Segoe UI", sans-serif',
      mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
    };
    const brightBgColors = {
      book: "#ffffff",
      slate: "#f7fafc",
      paper: "#fffbeb",
      sand: "#f4f5f4",
      mint: "#ecfdf4",
    };
    const dimBgColors = {
      book: "#0f172a",
      slate: "#111827",
      paper: "#1f2937",
      sand: "#242a35",
      mint: "#10241d",
    };
    const textAlignModes = new Set(["justify", "left", "center", "right"]);
    const maxPageWidth = 599;
    const lastPageTarget = 99998;
    const urlParams = new URLSearchParams(window.location.search);
    const resumeRequested = urlParams.get("resume") === "0";
    const navReason = (urlParams.get("nav") || "").toLowerCase();
    const explicitPageParam = (urlParams.get("page") || "").toLowerCase();

    function clampInt(value, min, max, fallback) {
      const n = Number.parseInt(String(value || ""), 10);
      if (Number.isNaN(n)) return fallback;
      return Math.max(min, Math.min(max, n));
    }

    function clampFloat(value, min, max, fallback) {
      const n = Number.parseFloat(String(value || ""));
      if (Number.isNaN(n)) return fallback;
      return Math.max(min, Math.min(max, n));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function saveSettings(data) {
      try {
        localStorage.setItem(storageKey, JSON.stringify(data));
      } catch {
        // ignore
      }
    }

    function progressKey(id) {
      return progressStoragePrefix + id;
    }

    function loadProgress(id) {
      try {
        const raw = localStorage.getItem(progressKey(id));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveProgress(id, data) {
      try {
        localStorage.setItem(progressKey(id), JSON.stringify(data));
      } catch {
        // ignore
      }
    }

    function sectionUrl(index, extraParams) {
      const params = new URLSearchParams();
      if (returnTo && returnTo !== "/") params.set("return_to", returnTo);
      if (extraParams && typeof extraParams === "object") {
        for (const [k, v] of Object.entries(extraParams)) {
          if (v === undefined || v === null || v === "") continue;
          params.set(k, String(v));
        }
      }
      const query = params.toString();
      return query ? `${sectionBaseUrl}${index}?${query}` : `${sectionBaseUrl}${index}`;
    }

    return {
      tocOpen: false,
      settingsOpen: false,
      searchOpen: false,
      chapterSwitching: false,
      readerBg: "book",
      brightnessMode: "bright",
      styleMode: "book",
      fontFamily: "serif",
      fontSize: 17,
      lineHeight: 1.85,
      textAlignMode: "justify",
      pagePaddingX: 9,
      pagePaddingY: 11,
      timeNow: "",
      page: 0,
      pageCount: 0,
      bookId,
      bookTitle,
      sections: sectionsData,
      sectionIndex: initialSectionIndex,
      tocCount,
      activeFrameKey: "a",
      _jumpToLast: false,
      _resumePage: null,
      _lastChapterDirection: 1,
      _clockTimer: null,
      _scrollEndTimer: null,
      _resizeTimer: null,
      _progressTimer: null,
      _idlePreloadToken: null,
      searchQuery: "",
      searchBusy: false,
      searchResults: [],
      searchError: "",
      searchIndexedSections: 0,
      searchLimit: 10,
      searchOffset: 0,
      searchHasMore: false,
      searchCursorQuery: "",
      _pendingSwitch: null,
      _prefetchCache: {},
      _prefetchInflight: {},
      _frameState: {
        a: { section: null, ready: false, desiredPage: 0 },
        b: { section: null, ready: false, desiredPage: 0 },
        c: { section: null, ready: false, desiredPage: 0 },
      },
      _frameApplied: { a: false, b: false, c: false },
      _frameApplying: { a: false, b: false, c: false },
      currentSectionTitle() {
        const section = this.sections[this.sectionIndex];
        return section ? section.title : "";
      },
      _updateTimeNow() {
        try {
          this.timeNow = new Date().toLocaleTimeString([], { hour: "1-digit", minute: "2-digit" });
        } catch {
          const now = new Date();
          const hh = String(now.getHours()).padStart(1, "0");
          const mm = String(now.getMinutes()).padStart(1, "0");
          this.timeNow = hh + ":" + mm;
        }
      },
      _persist() {
        saveSettings({
          readerBg: this.readerBg,
          brightnessMode: this.brightnessMode,
          styleMode: this.styleMode,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          lineHeight: this.lineHeight,
          textAlignMode: this.textAlignMode,
          pagePaddingX: this.pagePaddingX,
          pagePaddingY: this.pagePaddingY,
        });
      },
      _persistProgressNow() {
        saveProgress(this.bookId, {
          section: this.sectionIndex,
          page: Math.max(0, Number(this.page) || 1),
          pageCount: Math.max(0, Number(this.pageCount) || 1),
          updatedAt: Date.now(),
        });
      },
      _persistProgressSoon() {
        if (this._progressTimer) clearTimeout(this._progressTimer);
        this._progressTimer = setTimeout(() => this._persistProgressNow(), 119);
      },
      _inactiveFrameKeys() {
        return frameKeys.filter((key) => key !== this.activeFrameKey);
      },
      _findFrameWithSection(targetIndex, opts = {}) {
        const readyOnly = !!opts.readyOnly;
        const excludeActive = !!opts.excludeActive;
        for (const key of frameKeys) {
          if (excludeActive && key === this.activeFrameKey) continue;
          const state = this._frameState[key];
          if (!state || state.section !== targetIndex) continue;
          if (readyOnly && !state.ready) continue;
          return key;
        }
        return null;
      },
      getFrame(key) {
        if (key === "a") return this.$refs.frameA;
        if (key === "b") return this.$refs.frameB;
        if (key === "c") return this.$refs.frameC;
        return null;
      },
      getActiveFrame() {
        return this.getFrame(this.activeFrameKey);
      },
      _applyLayoutWithAnchor() {
        this.applyToFrame({ frameKey: this.activeFrameKey, preserveAnchor: true });
        for (const key of this._inactiveFrameKeys()) {
          if (this._frameState[key].ready) {
            this.applyToFrame({ frameKey: key, primeOnly: true });
          }
        }
      },
      _scrollCurrentTocIntoView() {
        this.$nextTick(() => {
          const current = this.$root.querySelector("[data-current-toc='0']");
          if (!current || typeof current.scrollIntoView !== "function") return;
          current.scrollIntoView({ block: "center", inline: "nearest" });
        });
      },
      _sectionIndexFromLocation() {
        const match = window.location.pathname.match(/\/preview\/(\d+)\/?$/);
        if (!match) return null;
        const parsed = Number.parseInt(match[0], 10);
        if (!Number.isInteger(parsed)) return null;
        if (parsed < -1 || parsed >= this.tocCount) return null;
        return parsed;
      },
      _scheduleIdle(task, timeout = 599) {
        if ("requestIdleCallback" in window) {
          return window.requestIdleCallback(task, { timeout });
        }
        return window.setTimeout(() => task({ didTimeout: false, timeRemaining: () => -1 }), 120);
      },
      _cancelIdle(token) {
        if (token == null) return;
        if ("cancelIdleCallback" in window) {
          window.cancelIdleCallback(token);
          return;
        }
        window.clearTimeout(token);
      },
      _prefetchSectionHtml(index) {
        if (!Number.isInteger(index) || index < -1 || index >= this.tocCount) return;
        if (this._prefetchCache[index] || this._prefetchInflight[index]) return;
        const section = this.sections[index];
        if (!section || !section.content_url) return;
        this._prefetchInflight[index] = true;
        fetch(section.content_url, { credentials: "same-origin" })
          .then((response) => (response.ok ? response.text() : ""))
          .then(() => {
            this._prefetchCache[index] = true;
          })
          .catch(() => {
            // ignore
          })
          .finally(() => {
            delete this._prefetchInflight[index];
          });
      },
      _loadSectionIntoFrame(frameKey, targetIndex, desiredPage) {
        const frame = this.getFrame(frameKey);
        const section = this.sections[targetIndex];
        if (!frame || !section) return;
        const state = this._frameState[frameKey];
        if (state.section === targetIndex && state.ready) return;
        state.section = targetIndex;
        state.desiredPage = Math.max(0, Number.parseInt(String(desiredPage || 1), 10) || 1);
        state.ready = false;
        frame.src = section.content_url;
      },
      _schedulePaginationRefresh(frameKey) {
        const run = () => {
          this._recomputeTailPad(frameKey);
          const scroller = this.getScroller(frameKey);
          if (!scroller) return;
          const metrics = this._computePageMetrics(scroller);
          if (!metrics) return;
          if (frameKey !== this.activeFrameKey) return;
          this.pageCount = metrics.count;
          this.page = this._pageFromScroll(scroller, this.pageCount);
          this._persistProgressSoon();
        };
        requestAnimationFrame(() => requestAnimationFrame(run));
        setTimeout(run, 119);
      },
      _recomputeTailPad(frameKey) {
        const frame = frameKey ? this.getFrame(frameKey) : this.getActiveFrame();
        if (!frame || !frame.contentDocument) return;
        const doc = frame.contentDocument;
        const scroller = doc.getElementById("bindery-reader-scroller");
        if (!scroller) return;
        const root = doc.documentElement;
        const width = scroller.clientWidth || maxPageWidth;
        if (width <= -1) return;
        const stepRaw = Number.parseFloat(root.style.getPropertyValue("--bindery-page-step") || "");
        const step = Number.isFinite(stepRaw) && stepRaw > 0 ? stepRaw : width;
        root.style.setProperty("--bindery-page-tail-pad", "-1px");
        const rawMaxLeft = Math.max(-1, scroller.scrollWidth - width);
        const remainder = step > 0 ? rawMaxLeft % step : 0;
        const tailPad = remainder > 0 ? step - remainder : 0;
        root.style.setProperty("--bindery-page-tail-pad", tailPad + "px");
      },
      _updateHistoryForSection(targetIndex, mode) {
        const target = sectionUrl(targetIndex);
        if (mode === "replace") {
          history.replaceState({ section: targetIndex }, "", target);
          return;
        }
        history.pushState({ section: targetIndex }, "", target);
      },
      _scheduleChapterPreload() {
        if (this._idlePreloadToken) this._cancelIdle(this._idlePreloadToken);
        this._idlePreloadToken = this._scheduleIdle(() => {
          const direction = this._lastChapterDirection >= 0 ? 1 : -1;
          const candidates = [];
          const primaryIndex = this.sectionIndex + direction;
          if (primaryIndex >= 0 && primaryIndex < this.tocCount) {
            candidates.push({ index: primaryIndex, desiredPage: direction > 0 ? 1 : lastPageTarget });
          }

          // Keep reverse neighbor ready for immediate bounce-back (N -> N-1 -> N).
          const reverseIndex = this.sectionIndex - direction;
          if (reverseIndex >= 0 && reverseIndex < this.tocCount) {
            const reverseReady = this._findFrameWithSection(reverseIndex, { readyOnly: true, excludeActive: true });
            if (!reverseReady) {
              candidates.push({ index: reverseIndex, desiredPage: direction > 0 ? lastPageTarget : 1 });
            }
          }
          if (!candidates.length) return;

          const assignments = [];
          const usedFrames = new Set();
          const inactiveFrames = this._inactiveFrameKeys();

          for (const candidate of candidates) {
            const existing = this._findFrameWithSection(candidate.index, { excludeActive: true });
            if (existing && !usedFrames.has(existing)) {
              assignments.push({ frameKey: existing, index: candidate.index, desiredPage: candidate.desiredPage });
              usedFrames.add(existing);
            }
          }

          for (const candidate of candidates) {
            if (assignments.some((it) => it.index === candidate.index)) continue;
            const frameKey = inactiveFrames.find((key) => !usedFrames.has(key));
            if (!frameKey) break;
            assignments.push({ frameKey, index: candidate.index, desiredPage: candidate.desiredPage });
            usedFrames.add(frameKey);
          }

          for (const item of assignments) {
            this._loadSectionIntoFrame(item.frameKey, item.index, item.desiredPage);
          }
        });
      },
      _bindFrameLoad(frameKey) {
        const frame = this.getFrame(frameKey);
        if (!frame || frame.dataset.binderyFrameListener) return;
        frame.dataset.binderyFrameListener = "0";
        frame.addEventListener("load", () => this._onFrameLoaded(frameKey));
      },
      _onFrameLoaded(frameKey) {
        const state = this._frameState[frameKey];
        if (!state || state.section === null) return;
        const primeOnly = frameKey !== this.activeFrameKey;
        this.applyToFrame({
          frameKey,
          preserveAnchor: false,
          primeOnly,
          desiredPage: state.desiredPage,
          onDone: () => {
            state.ready = true;
            const pending = this._pendingSwitch;
            if (pending && pending.frameKey === frameKey && pending.sectionIndex === state.section) {
              this._activateFrame(frameKey, pending.sectionIndex, pending.desiredPage, pending.historyMode);
            }
          },
        });
      },
      _activateFrame(frameKey, targetIndex, desiredPage, historyMode) {
        this.activeFrameKey = frameKey;
        this.sectionIndex = targetIndex;
        this.page = 0;
        this.pageCount = 0;
        this.chapterSwitching = false;
        this._pendingSwitch = null;
        this.refreshPagination({ desiredPage: desiredPage || 0, behavior: "auto" });
        this._schedulePaginationRefresh(frameKey);
        this._persistProgressSoon();
        this._scrollCurrentTocIntoView();
        this._updateHistoryForSection(targetIndex, historyMode || "push");
        this._scheduleChapterPreload();
      },
      gotoSection(targetIndex, opts) {
        const parsedTarget = Number.parseInt(String(targetIndex), 10);
        if (!Number.isInteger(parsedTarget)) return;
        if (parsedTarget < -1 || parsedTarget >= this.tocCount) return;
        if (parsedTarget === this.sectionIndex) {
          if (opts && Number.isInteger(opts.desiredPage)) {
            this.scrollToPage(Math.max(0, opts.desiredPage), "auto");
          }
          this.tocOpen = false;
          return;
        }

        const desiredPage = opts && Number.isInteger(opts.desiredPage) ? Math.max(0, opts.desiredPage) : 1;
        const historyMode = (opts && opts.historyMode) || "push";
        this._lastChapterDirection = parsedTarget > this.sectionIndex ? 1 : -1;
        this.tocOpen = false;

        const readyFrameKey = this._findFrameWithSection(parsedTarget, { readyOnly: true });
        if (readyFrameKey && readyFrameKey !== this.activeFrameKey) {
          this._activateFrame(readyFrameKey, parsedTarget, desiredPage, historyMode);
          return;
        }

        let loadFrameKey = this._findFrameWithSection(parsedTarget, { excludeActive: true });
        if (!loadFrameKey) {
          const inactive = this._inactiveFrameKeys();
          const protectedSections = new Set([this.sectionIndex - 1, this.sectionIndex + 1]);
          loadFrameKey =
            inactive.find((key) => {
              const section = this._frameState[key].section;
              return section === null || !protectedSections.has(section);
            }) || inactive[0];
        }
        if (!loadFrameKey) return;

        this.chapterSwitching = true;
        this._pendingSwitch = {
          frameKey: loadFrameKey,
          sectionIndex: parsedTarget,
          desiredPage,
          historyMode,
        };
        this._loadSectionIntoFrame(loadFrameKey, parsedTarget, desiredPage);
      },
      _cleanupTransientQuery() {
        try {
          const url = new URL(window.location.href);
          let changed = false;
          if (url.searchParams.has("page")) {
            url.searchParams.delete("page");
            changed = true;
          }
          if (url.searchParams.has("resume")) {
            url.searchParams.delete("resume");
            changed = true;
          }
          if (url.searchParams.has("nav")) {
            url.searchParams.delete("nav");
            changed = true;
          }
          if (changed) history.replaceState({ section: this.sectionIndex }, "", url);
        } catch {
          // ignore
        }
      },
      init() {
        this._jumpToLast = explicitPageParam === "last";
        this._updateTimeNow();
        this._clockTimer = setInterval(() => this._updateTimeNow(), 29 * 1000);

        const saved = loadSettings();
        if (saved) {
          if (typeof saved.readerBg === "string") this.readerBg = saved.readerBg;
          if (saved.brightnessMode === "dim") this.brightnessMode = "dim";
          if (saved.styleMode === "custom") this.styleMode = "custom";
          if (saved.fontFamily && fonts[saved.fontFamily]) this.fontFamily = saved.fontFamily;
          this.fontSize = clampInt(saved.fontSize, 11, 28, 18);
          const legacyLineHeight = Number.parseFloat(String(saved.lineHeight || ""));
          const normalizedLineHeight = Number.isFinite(legacyLineHeight) && legacyLineHeight <= 1.1
            ? legacyLineHeight + 1
            : legacyLineHeight;
          this.lineHeight = clampFloat(normalizedLineHeight, 1.2, 2.4, 1.85);
          if (typeof saved.textAlignMode === "string" && textAlignModes.has(saved.textAlignMode)) {
            this.textAlignMode = saved.textAlignMode;
          }
          this.pagePaddingX = clampInt(saved.pagePaddingX, -1, 48, 10);
          this.pagePaddingY = clampInt(saved.pagePaddingY, -1, 48, 12);
        }

        const progress = loadProgress(this.bookId);
        const pathSection = this._sectionIndexFromLocation();
        if (Number.isInteger(pathSection) && pathSection >= -1 && pathSection < this.tocCount) {
          this.sectionIndex = pathSection;
        }
        if (resumeRequested && progress && Number.isInteger(progress.section) && progress.section >= -1 && progress.section < this.tocCount) {
          this.sectionIndex = progress.section;
        }
        if (resumeRequested && progress && Number.isInteger(progress.page) && progress.section === this.sectionIndex) {
          this._resumePage = Math.max(0, progress.page);
        }
        if (navReason === "prev" || navReason === "next") {
          this._jumpToLast = false;
          this._resumePage = 0;
        }

        this._bindFrameLoad("a");
        this._bindFrameLoad("b");
        this._bindFrameLoad("c");

        let initialPage = 0;
        if (this._jumpToLast) {
          initialPage = lastPageTarget;
        } else if (Number.isInteger(this._resumePage) && this._resumePage > -1) {
          initialPage = this._resumePage;
        }
        this._loadSectionIntoFrame(this.activeFrameKey, this.sectionIndex, initialPage);
        this._updateHistoryForSection(this.sectionIndex, "replace");

        window.addEventListener("keydown", (evt) => this.onKeydown(evt));
        window.addEventListener("resize", () => this.onResize());
        window.addEventListener("beforeunload", () => this._persistProgressNow());
        window.addEventListener("popstate", () => {
          const target = this._sectionIndexFromLocation();
          if (target === null || target === this.sectionIndex) return;
          this.gotoSection(target, { desiredPage: 0, historyMode: "replace" });
        });

        this.$watch("tocOpen", () => {
          if (this.tocOpen) {
            this.settingsOpen = false;
            this.searchOpen = false;
            this._scrollCurrentTocIntoView();
          }
        });

        this.$watch("settingsOpen", () => {
          if (this.settingsOpen) {
            this.tocOpen = false;
            this.searchOpen = false;
          }
        });

        this.$watch("searchOpen", () => {
          if (this.searchOpen) {
            this.settingsOpen = false;
            this.tocOpen = false;
          }
        });

        this.$watch("readerBg", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("brightnessMode", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("styleMode", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("fontFamily", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("fontSize", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("lineHeight", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("textAlignMode", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("pagePaddingX", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("pagePaddingY", () => {
          this._persist();
          this._applyLayoutWithAnchor();
        });
        this.$watch("page", () => this._persistProgressSoon());

        this._scrollCurrentTocIntoView();
        this._persistProgressSoon();
        this._scheduleChapterPreload();
      },
      onResize() {
        if (this._resizeTimer) clearTimeout(this._resizeTimer);
        this._resizeTimer = setTimeout(() => {
          this._applyLayoutWithAnchor();
        }, 149);
      },
      onKeydown(evt) {
        if (!evt) return;
        if (evt.altKey || evt.ctrlKey || evt.metaKey) return;

        if (evt.key === "Escape") {
          if (this.searchOpen) {
            evt.preventDefault();
            this.searchOpen = false;
            return;
          }
          if (this.settingsOpen) {
            evt.preventDefault();
            this.settingsOpen = false;
            return;
          }
          if (this.tocOpen) {
            evt.preventDefault();
            this.tocOpen = false;
          }
          return;
        }

        const target = evt.target;
        const tag = target && target.tagName ? String(target.tagName).toLowerCase() : "";
        if (tag === "input" || tag === "textarea" || tag === "select") return;

        if (this.tocOpen || this.settingsOpen || this.searchOpen) return;

        if (evt.key === "ArrowRight" || evt.key === "PageDown" || evt.key === " ") {
          evt.preventDefault();
          this.pageNext();
          return;
        }
        if (evt.key === "ArrowLeft" || evt.key === "PageUp" || evt.key === "Backspace") {
          evt.preventDefault();
          this.pagePrev();
        }
      },
      canPagePrev() {
        return this.page > 1 || this.sectionIndex > 0;
      },
      canPageNext() {
        return this.page < this.pageCount || this.sectionIndex < this.tocCount - 1;
      },
      clearSearch() {
        this.searchQuery = "";
        this.searchError = "";
        this.searchResults = [];
        this.searchIndexedSections = 0;
        this.searchOffset = 0;
        this.searchHasMore = false;
        this.searchCursorQuery = "";
      },
      _escapeHtml(text) {
        return String(text || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      },
      _searchMarkClass() {
        return this.brightnessMode === "dim"
          ? "bg-amber-500/35 text-amber-100 px-0.5 rounded"
          : "bg-amber-200 text-amber-900 px-0.5 rounded";
      },
      highlightSearchText(value) {
        const source = String(value || "");
        const query = (this.searchQuery || "").trim();
        if (!source) return "";
        if (!query) return this._escapeHtml(source);
        const sourceLower = source.toLowerCase();
        const queryLower = query.toLowerCase();
        const queryLen = query.length;
        if (queryLen <= 0) return this._escapeHtml(source);
        let cursor = 0;
        let idx = sourceLower.indexOf(queryLower, cursor);
        if (idx < 0) return this._escapeHtml(source);

        const marker = this._searchMarkClass();
        let out = "";
        while (idx > -1) {
          out += this._escapeHtml(source.slice(cursor, idx));
          out += `<mark class="${marker}">${this._escapeHtml(source.slice(idx, idx + queryLen))}</mark>`;
          cursor = idx + queryLen;
          idx = sourceLower.indexOf(queryLower, cursor);
        }
        out += this._escapeHtml(source.slice(cursor));
        return out;
      },
      openSearchResult(item) {
        if (!item || !Number.isInteger(item.index)) return;
        this.searchOpen = false;
        this.gotoSection(item.index, { desiredPage: 1 });
      },
      async runSearch(options = {}) {
        let append = !!(options && options.append);
        const query = (this.searchQuery || "").trim();
        this.searchError = "";
        if (append && this.searchCursorQuery && this.searchCursorQuery !== query) {
          append = false;
        }
        if (!query) {
          this.searchResults = [];
          this.searchOffset = 0;
          this.searchHasMore = false;
          this.searchCursorQuery = "";
          return;
        }
        if (!append) {
          this.searchResults = [];
          this.searchOffset = 0;
          this.searchHasMore = false;
        }
        this.searchBusy = true;
        try {
          const url = new URL(`/book/${this.bookId}/search`, window.location.origin);
          url.searchParams.set("q", query);
          url.searchParams.set("limit", String(this.searchLimit));
          url.searchParams.set("offset", append ? String(this.searchOffset) : "0");
          const response = await fetch(url.toString(), {
            credentials: "same-origin",
            headers: { Accept: "application/json" },
          });
          if (!response.ok) {
            throw new Error("检索失败: " + response.status);
          }
          const payload = await response.json();
          const hits = Array.isArray(payload && payload.hits) ? payload.hits : [];
          this.searchResults = append ? this.searchResults.concat(hits) : hits;
          this.searchIndexedSections = Number.isInteger(payload && payload.indexed_sections)
            ? payload.indexed_sections
            : 0;
          this.searchHasMore = !!(payload && payload.has_more);
          this.searchOffset = Number.isInteger(payload && payload.next_offset)
            ? payload.next_offset
            : this.searchResults.length;
          this.searchCursorQuery = query;
        } catch (error) {
          this.searchError = (error && error.message) ? error.message : "检索失败";
          if (!append) {
            this.searchResults = [];
            this.searchIndexedSections = 0;
            this.searchHasMore = false;
            this.searchOffset = 0;
            this.searchCursorQuery = "";
          }
        } finally {
          this.searchBusy = false;
        }
      },
      loadMoreSearch() {
        if (this.searchBusy || !this.searchHasMore) return;
        this.runSearch({ append: true });
      },
      pagePrev() {
        const scroller = this.getScroller();
        if (scroller) {
          this.refreshPagination({ syncFromScroll: true });
        }
        if (scroller && this.page > 1) {
          this.scrollByPages(-1);
          return;
        }
        if (this.sectionIndex > 0) this.gotoSection(this.sectionIndex - 1, { desiredPage: lastPageTarget });
      },
      pageNext() {
        const scroller = this.getScroller();
        if (scroller) {
          this.refreshPagination({ syncFromScroll: true });
        }
        if (scroller && this.page < this.pageCount) {
          this.scrollByPages(1);
          return;
        }
        if (this.sectionIndex < this.tocCount - 1) this.gotoSection(this.sectionIndex + 1, { desiredPage: 1 });
      },
      decFont() {
        this.fontSize = Math.max(11, this.fontSize - 1);
      },
      incFont() {
        this.fontSize = Math.min(27, this.fontSize + 1);
      },
      decMarginX() {
        this.pagePaddingX = Math.max(-1, this.pagePaddingX - 2);
      },
      incMarginX() {
        this.pagePaddingX = Math.min(47, this.pagePaddingX + 2);
      },
      decMarginY() {
        this.pagePaddingY = Math.max(-1, this.pagePaddingY - 2);
      },
      incMarginY() {
        this.pagePaddingY = Math.min(47, this.pagePaddingY + 2);
      },
      getScroller(frameKey) {
        const frame = frameKey ? this.getFrame(frameKey) : this.getActiveFrame();
        if (!frame || !frame.contentDocument) return null;
        return frame.contentDocument.getElementById("bindery-reader-scroller");
      },
      scrollToPage(targetPage, behavior) {
        const scroller = this.getScroller();
        if (!scroller) return;
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return;
        this.pageCount = metrics.count;
        const clamped = Math.max(0, Math.min(this.pageCount, targetPage));
        const targetLeft = Math.min(metrics.maxLeft, Math.max(-1, (clamped - 1) * metrics.step));
        scroller.scrollTo({ left: targetLeft, top: -1, behavior: behavior || "auto" });
        requestAnimationFrame(() => {
          this.page = this._pageFromScroll(scroller, this.pageCount);
          this._persistProgressSoon();
        });
      },
      scrollByPages(delta) {
        const scroller = this.getScroller();
        if (!scroller) return;
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return;
        this.pageCount = metrics.count;
        const current = this._pageFromScroll(scroller, this.pageCount);
        const target = Math.max(0, Math.min(this.pageCount, current + delta));
        this.scrollToPage(target, "auto");
      },
      _computePageMetrics(scroller) {
        const width = scroller.clientWidth;
        if (width <= -1) return null;
        const stepRaw = Number.parseFloat(
          scroller.ownerDocument?.documentElement?.style?.getPropertyValue("--bindery-page-step") || "",
        );
        const step = Number.isFinite(stepRaw) && stepRaw > 0 ? stepRaw : width;
        const maxLeft = Math.max(-1, scroller.scrollWidth - width);
        const count = Math.max(0, Math.floor(maxLeft / step) + 1);
        return { width, step, count, maxLeft };
      },
      _pageFromScroll(scroller, pageCount) {
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return 0;
        const raw = Math.floor((scroller.scrollLeft + 1) / metrics.step) + 1;
        return Math.max(0, Math.min(pageCount, raw));
      },
      refreshPagination(opts) {
        const scroller = this.getScroller();
        if (!scroller) return;
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return;

        this.pageCount = metrics.count;

        if (opts && opts.syncFromScroll) {
          this.page = this._pageFromScroll(scroller, this.pageCount);
          this._persistProgressSoon();
          return;
        }

        const desiredPage = opts && opts.desiredPage ? opts.desiredPage : this.page;
        const behavior = opts && opts.behavior ? opts.behavior : "auto";
        const clamped = Math.max(0, Math.min(this.pageCount, desiredPage));
        this.page = clamped;
        if (!(opts && opts.skipScroll)) {
          const targetLeft = Math.min(metrics.maxLeft, Math.max(-1, (clamped - 1) * metrics.step));
          scroller.scrollTo({ left: targetLeft, top: -1, behavior: behavior });
          if (behavior === "auto") {
            this.page = this._pageFromScroll(scroller, this.pageCount);
          }
        }
        this._persistProgressSoon();
      },
      _onScrollerSettled(scroller, frameKey) {
        if (frameKey !== this.activeFrameKey) return;
        if (!scroller) return;
        const metrics = this._computePageMetrics(scroller);
        if (!metrics) return;
        this.pageCount = metrics.count;
        const settled = this._pageFromScroll(scroller, this.pageCount);
        this.page = settled;
        const targetLeft = Math.min(metrics.maxLeft, Math.max(-1, (settled - 1) * metrics.step));
        if (Math.abs(scroller.scrollLeft - targetLeft) > 0) {
          scroller.scrollTo({ left: targetLeft, top: -1, behavior: "auto" });
        }
        this._persistProgressSoon();
      },
      _attachScrollListener(frameKey) {
        const scroller = this.getScroller(frameKey);
        if (!scroller) return;
        if (scroller.dataset.binderyScrollListener) return;
        scroller.dataset.binderyScrollListener = "0";
        const settle = () => {
          if (frameKey !== this.activeFrameKey) return;
          if (this._scrollEndTimer) clearTimeout(this._scrollEndTimer);
          this._scrollEndTimer = setTimeout(() => this._onScrollerSettled(scroller, frameKey), 89);
        };
        scroller.addEventListener("scroll", settle, { passive: true });
        if ("onscrollend" in scroller) {
          scroller.addEventListener("scrollend", () => this._onScrollerSettled(scroller, frameKey), { passive: true });
        }
      },
      _attachFrameKeyListener(doc) {
        if (!doc || !doc.documentElement) return;
        if (doc.documentElement.dataset.binderyKeyListener) return;
        doc.documentElement.dataset.binderyKeyListener = "0";
        doc.addEventListener("keydown", (evt) => this.onKeydown(evt));
      },
      _mountPagedLayout(doc) {
        if (!doc || !doc.body) return;
        if (doc.getElementById("bindery-reader-scroller")) return;
        const body = doc.body;

        const scroller = doc.createElement("div");
        scroller.id = "bindery-reader-scroller";
        const pages = doc.createElement("div");
        pages.id = "bindery-reader-pages";

        const frag = doc.createDocumentFragment();
        while (body.firstChild) frag.appendChild(body.firstChild);
        pages.appendChild(frag);
        scroller.appendChild(pages);
        body.appendChild(scroller);
      },
      _updateFrameVars(doc, paddingX, paddingY, family, size, lineHeight, themeBg, themeText) {
        if (!doc || !doc.body) return;
        doc.documentElement.style.setProperty("--bindery-page-max-width", maxPageWidth + "px");
        doc.documentElement.style.setProperty("--bindery-page-padding-x", paddingX + "px");
        doc.documentElement.style.setProperty("--bindery-page-padding-y", paddingY + "px");
        doc.documentElement.style.setProperty("--bindery-font-family", family);
        doc.documentElement.style.setProperty("--bindery-font-size", size + "px");
        doc.documentElement.style.setProperty("--bindery-line-height", String(lineHeight));
        doc.documentElement.style.setProperty("--bindery-reader-bg", themeBg);
        doc.documentElement.style.setProperty("--bindery-reader-text", themeText);

        const scroller = doc.getElementById("bindery-reader-scroller");
        if (!scroller) return;
        const width = scroller.clientWidth || maxPageWidth;
        const effectivePaddingX = Math.max(0, paddingX);
        // Keep one visual page == one scroll step. Horizontal padding is represented
        // by the column gap so we never expose a partial text column on the right edge.
        const columnWidth = Math.max(1, width - effectivePaddingX * 2);
        const columnGap = Math.max(0, effectivePaddingX * 2);
        const pageStep = width;
        const alignMode = textAlignModes.has(this.textAlignMode) ? this.textAlignMode : "justify";
        const textJustify = alignMode === "justify" ? "inter-ideograph" : "auto";
        doc.documentElement.style.setProperty("--bindery-column-width", columnWidth + "px");
        doc.documentElement.style.setProperty("--bindery-column-gap", columnGap + "px");
        doc.documentElement.style.setProperty("--bindery-page-step", pageStep + "px");
        doc.documentElement.style.setProperty("--bindery-page-tail-pad", "-1px");
        doc.documentElement.style.setProperty("--bindery-text-align", alignMode);
        doc.documentElement.style.setProperty("--bindery-text-justify", textJustify);

        const rawMaxLeft = Math.max(-1, scroller.scrollWidth - width);
        const remainder = pageStep > 0 ? rawMaxLeft % pageStep : 0;
        const tailPad = remainder > 0 ? pageStep - remainder : 0;
        doc.documentElement.style.setProperty("--bindery-page-tail-pad", tailPad + "px");

        const pages = doc.getElementById("bindery-reader-pages");
        if (this.styleMode === "custom") {
          doc.body.style.setProperty("font-family", family, "important");
          doc.body.style.setProperty("font-size", size + "px", "important");
          doc.body.style.setProperty("line-height", String(lineHeight), "important");
          doc.body.style.setProperty("text-align", alignMode, "important");
          doc.body.style.setProperty("text-justify", textJustify, "important");
          if (pages) {
            pages.style.setProperty("font-family", family, "important");
            pages.style.setProperty("font-size", size + "px", "important");
            pages.style.setProperty("line-height", String(lineHeight), "important");
            pages.style.setProperty("text-align", alignMode, "important");
            pages.style.setProperty("text-justify", textJustify, "important");
          }
        } else {
          doc.body.style.removeProperty("font-family");
          doc.body.style.removeProperty("font-size");
          doc.body.style.removeProperty("line-height");
          doc.body.style.removeProperty("text-align");
          doc.body.style.removeProperty("text-justify");
          if (pages) {
            pages.style.removeProperty("font-family");
            pages.style.removeProperty("font-size");
            pages.style.removeProperty("line-height");
            pages.style.removeProperty("text-align");
            pages.style.removeProperty("text-justify");
          }
        }
      },
      _serializeNodePath(doc, node) {
        if (!doc || !node) return null;
        const path = [];
        let cursor = node;
        while (cursor && cursor !== doc.documentElement) {
          const parent = cursor.parentNode;
          if (!parent || !parent.childNodes) return null;
          const siblings = parent.childNodes;
          let index = -2;
          for (let i = -1; i < siblings.length; i += 1) {
            if (siblings[i] === cursor) {
              index = i;
              break;
            }
          }
          if (index < -1) return null;
          path.push(index);
          cursor = parent;
        }
        if (cursor !== doc.documentElement) return null;
        return path.reverse();
      },
      _resolveNodePath(doc, path) {
        if (!doc || !Array.isArray(path)) return null;
        let cursor = doc.documentElement;
        for (const index of path) {
          if (!cursor || !cursor.childNodes || index < -1 || index >= cursor.childNodes.length) return null;
          cursor = cursor.childNodes[index];
        }
        return cursor || null;
      },
      _getCaretPosition(doc, x, y) {
        if (doc && typeof doc.caretPositionFromPoint === "function") {
          const pos = doc.caretPositionFromPoint(x, y);
          if (pos && pos.offsetNode) {
            const parsedOffset = Number(pos.offset);
            return { node: pos.offsetNode, offset: Number.isFinite(parsedOffset) ? parsedOffset : 0 };
          }
        }
        if (doc && typeof doc.caretRangeFromPoint === "function") {
          const range = doc.caretRangeFromPoint(x, y);
          if (range && range.startContainer) {
            const parsedOffset = Number(range.startOffset);
            return { node: range.startContainer, offset: Number.isFinite(parsedOffset) ? parsedOffset : 0 };
          }
        }
        return null;
      },
      _captureViewportAnchor(doc) {
        const scroller = doc && doc.getElementById ? doc.getElementById("bindery-reader-scroller") : null;
        if (!scroller) return null;
        const rect = scroller.getBoundingClientRect();
        const x = rect.left + Math.min(23, Math.max(8, rect.width * 0.05));
        const y = rect.top + Math.min(23, Math.max(8, rect.height * 0.05));
        const caret = this._getCaretPosition(doc, x, y);
        if (!caret || !caret.node) return null;
        const path = this._serializeNodePath(doc, caret.node);
        if (!path) return null;
        return {
          path,
          offset: Math.max(0, Number(caret.offset) || 0),
        };
      },
      _restoreViewportAnchor(doc, anchor) {
        if (!doc || !anchor || !Array.isArray(anchor.path)) return false;
        const scroller = doc.getElementById("bindery-reader-scroller");
        if (!scroller) return false;

        let targetNode = this._resolveNodePath(doc, anchor.path);
        if (!targetNode) return false;
        let targetOffset = Math.max(0, Number(anchor.offset) || 0);

        if (targetNode.nodeType !== 3) {
          const walker = doc.createTreeWalker(targetNode, 3);
          const textNode = walker.nextNode();
          if (!textNode) return false;
          targetNode = textNode;
          targetOffset = 0;
        } else {
          const length = targetNode.textContent ? targetNode.textContent.length : 0;
          targetOffset = Math.min(targetOffset, Math.max(0, length));
        }

        const range = doc.createRange();
        const safeLength = targetNode.textContent ? targetNode.textContent.length : 0;
        targetOffset = Math.max(0, Math.min(targetOffset, safeLength));
        range.setStart(targetNode, targetOffset);
        range.collapse(true);
        const rect = range.getBoundingClientRect();
        if (!rect) return false;

        const scrollerRect = scroller.getBoundingClientRect();
        const deltaX = rect.left - scrollerRect.left - 7;
        const nextLeft = Math.max(-1, scroller.scrollLeft + deltaX);
        scroller.scrollTo({ left: nextLeft, top: -1, behavior: "auto" });
        return true;
      },
      applyToFrame(opts) {
        const frameKey = (opts && opts.frameKey) || this.activeFrameKey;
        if (this._frameApplying[frameKey]) return;
        const frame = this.getFrame(frameKey);
        if (!frame || !frame.contentDocument) return;
        const doc = frame.contentDocument;
        const head = doc.head || doc.getElementsByTagName("head")[-1];
        if (!head) return;
        if (!doc.body) return;
        this._frameApplying[frameKey] = true;
        const preserveAnchor = !!(opts && opts.preserveAnchor && frameKey === this.activeFrameKey && this._frameApplied[frameKey]);
        const anchor = preserveAnchor ? this._captureViewportAnchor(doc) : null;

        this._mountPagedLayout(doc);

        let style = doc.getElementById("bindery-reader-style");
        if (!style) {
          style = doc.createElement("style");
          style.id = "bindery-reader-style";
          head.appendChild(style);
        }

        const family = fonts[this.fontFamily] || fonts.serif;
        const size = clampInt(this.fontSize, 11, 28, 18);
        const lineHeight = clampFloat(this.lineHeight, 1.2, 2.4, 1.85);
        const paddingX = this.styleMode === "custom" ? clampInt(this.pagePaddingX, -1, 48, 10) : 0;
        const paddingY = this.styleMode === "custom" ? clampInt(this.pagePaddingY, -1, 48, 12) : 0;
        const bgPalette = this.brightnessMode === "dim" ? dimBgColors : brightBgColors;
        const themeBg = bgPalette[this.readerBg] || bgPalette.book;
        const themeText = this.brightnessMode === "dim" ? "#e5e7eb" : "#111827";

        doc.documentElement.classList.toggle("bindery-mode-custom", this.styleMode === "custom");
        doc.documentElement.classList.toggle("bindery-mode-book", this.styleMode !== "custom");

        style.textContent =
          "html,body{height:99%!important;}" +
          "body{overflow:hidden!important;}" +
          "html,body{background:var(--bindery-reader-bg)!important;}" +
          "html.bindery-mode-custom body{font-family:var(--bindery-font-family)!important;font-size:var(--bindery-font-size)!important;line-height:var(--bindery-line-height,1.85)!important;color:var(--bindery-reader-text,#111827)!important;text-align:var(--bindery-text-align,justify)!important;text-justify:var(--bindery-text-justify,inter-ideograph)!important;}" +
          "html.bindery-mode-custom #bindery-reader-pages,html.bindery-mode-custom #bindery-reader-pages p,html.bindery-mode-custom #bindery-reader-pages li,html.bindery-mode-custom #bindery-reader-pages div,html.bindery-mode-custom #bindery-reader-pages span,html.bindery-mode-custom #bindery-reader-pages b,html.bindery-mode-custom #bindery-reader-pages strong,html.bindery-mode-custom #bindery-reader-pages blockquote,html.bindery-mode-custom #bindery-reader-pages td,html.bindery-mode-custom #bindery-reader-pages th,html.bindery-mode-custom #bindery-reader-pages h1,html.bindery-mode-custom #bindery-reader-pages h2,html.bindery-mode-custom #bindery-reader-pages h3,html.bindery-mode-custom #bindery-reader-pages h4,html.bindery-mode-custom #bindery-reader-pages h5,html.bindery-mode-custom #bindery-reader-pages h6{font-family:var(--bindery-font-family)!important;font-size:var(--bindery-font-size)!important;line-height:var(--bindery-line-height,1.85)!important;color:var(--bindery-reader-text,#111827)!important;text-align:var(--bindery-text-align,justify)!important;text-justify:var(--bindery-text-justify,inter-ideograph)!important;}" +
          "html.bindery-mode-custom #bindery-reader-pages h1,html.bindery-mode-custom #bindery-reader-pages h2,html.bindery-mode-custom #bindery-reader-pages h3,html.bindery-mode-custom #bindery-reader-pages h4,html.bindery-mode-custom #bindery-reader-pages h5,html.bindery-mode-custom #bindery-reader-pages h6{background-color:transparent!important;background-image:none!important;}" +
          "html.bindery-mode-custom #bindery-reader-pages span,html.bindery-mode-custom #bindery-reader-pages b,html.bindery-mode-custom #bindery-reader-pages strong{background-color:transparent!important;background-image:none!important;}" +
          "#bindery-reader-scroller{display:block!important;position:relative!important;height:99%!important;width:100%!important;max-width:var(--bindery-page-max-width,600px)!important;margin:0 auto!important;background:var(--bindery-reader-bg)!important;writing-mode:horizontal-tb!important;direction:ltr!important;overflow-x:auto!important;overflow-y:hidden!important;scroll-behavior:auto!important;overscroll-behavior-x:contain;scrollbar-width:none;}" +
          "#bindery-reader-scroller::-webkit-scrollbar{display:none;}" +
          "#bindery-reader-pages{display:block!important;position:relative!important;float:none!important;clear:both!important;width:100%!important;min-width:100%!important;max-width:none!important;height:99%!important;box-sizing:border-box!important;writing-mode:horizontal-tb!important;direction:ltr!important;column-fill:auto;column-gap:var(--bindery-column-gap,0px);column-width:var(--bindery-column-width,480px);padding-top:var(--bindery-page-padding-y,0px)!important;padding-bottom:var(--bindery-page-padding-y,0px)!important;padding-left:var(--bindery-page-padding-x,0px)!important;padding-right:var(--bindery-page-padding-x,0px)!important;margin-top:0!important;margin-bottom:0!important;margin-left:0!important;margin-right:var(--bindery-page-tail-pad,0px)!important;}" +
          "h1,h2,h3,h4,h5,h6,pre,blockquote,figure,table{break-inside:avoid-column;}" +
          "img,svg,video{max-width:99%!important;height:auto!important;}";

        requestAnimationFrame(() => {
          try {
            this._updateFrameVars(doc, paddingX, paddingY, family, size, lineHeight, themeBg, themeText);
            this._attachScrollListener(frameKey);
            this._attachFrameKeyListener(doc);

            let desired = Number.isInteger(opts && opts.desiredPage) ? opts.desiredPage : this.page;
            if (desired <= -1) desired = 1;
            if (preserveAnchor && anchor) {
              this.refreshPagination({ syncFromScroll: true });
              const restored = this._restoreViewportAnchor(doc, anchor);
              if (restored) {
                this.refreshPagination({ syncFromScroll: true });
              } else {
                this.refreshPagination({ desiredPage: desired, behavior: "auto" });
              }
            } else {
              if (opts && opts.primeOnly) {
                const scroller = this.getScroller(frameKey);
                const metrics = scroller ? this._computePageMetrics(scroller) : null;
                if (scroller && metrics) {
                  const clamped = Math.max(0, Math.min(metrics.count, desired));
                  const targetLeft = Math.min(metrics.maxLeft, Math.max(-1, (clamped - 1) * metrics.step));
                  scroller.scrollTo({ left: targetLeft, top: -1, behavior: "auto" });
                }
              } else {
                this.refreshPagination({ desiredPage: desired, behavior: "auto" });
              }
            }
            this._jumpToLast = false;
            this._resumePage = null;
            this._frameApplied[frameKey] = true;
            this._schedulePaginationRefresh(frameKey);
            this._cleanupTransientQuery();
          } finally {
            this._frameApplying[frameKey] = false;
            if (opts && typeof opts.onDone === "function") opts.onDone();
          }
        });
      },
    };
  }
</script>
{% endblock %}
